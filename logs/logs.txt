Running on local URL:  http://127.0.0.1:7860

To create a public link, set `share=True` in `launch()`.
action: set_working_folder -> {'name': 'set_working_folder', 'group': 'file_actions', 'pointer': <function set_working_folder at 0x00000257EEE74550>, 'agent_action': {'type': 'function', 'function': {'name': 'set_working_folder', 'description': '\n    Set the working folder for file operations.\n\n    :param foldername: The name of the folder to set as the working folder.\n    ', 'parameters': {'type': 'object', 'properties': {'foldername': {'type': 'string', 'description': 'foldername'}}, 'required': ['foldername']}}}, 'prompt_template': None}
action: set_working_folder -> {'foldername': 'G:\\My Drive\\Blog\\blog_1_1'}
action: set_working_folder(args={"foldername":"G:\\My Drive\\Blog\\blog_1_1"}) -> Working folder set to 'G:\My Drive\Blog\blog_1_1'.
assistant > action: extract_all_from_doc -> {'name': 'extract_all_from_doc', 'group': 'word_actions', 'pointer': <function extract_all_from_doc at 0x00000257901B8670>, 'agent_action': {'type': 'function', 'function': {'name': 'extract_all_from_doc', 'description': '\n    Extract all text, images, and code from a Word document.\n\n    Parameters:\n    doc_filename (str): Path to the Word document (.docx).\n    output_folder (str): Directory to save the extracted images and code files.\n\n    Returns:\n    str: Full document text with placeholders for images and code.\n    list: List of paths to the extracted images.\n    list: List of paths to the extracted code files.\n    ', 'parameters': {'type': 'object', 'properties': {'doc_filename': {'type': 'string', 'description': 'doc_filename'}, 'output_folder': {'type': 'string', 'description': 'output_folder'}}, 'required': ['doc_filename', 'output_folder']}}}, 'prompt_template': None}
action: extract_all_from_doc -> {'doc_filename': 'understanding_retrieval_in_agentic_systems.docx', 'output_folder': 'images'}
action: extract_all_from_doc(args={"doc_filename":"understanding_retrieval_in_agentic_systems.docx","output_folder":"images"}) -> ('\n\n\n\n\n\n\n\nAssembling and using an agent platform\nThis chapter covers\nUnderstanding how retrieval is used in knowledge and memory in AI applications functions\nUsing retrieval with semantic search and document indexing\nBuilding retrieval-augmented generation workflows with LangChain\nIntroducing RAG for agentic knowledge systems within Nexus.\nImplementing the retrieval pattern for memory in agents that consume various forms of memory, from conversation, semantic, episodic, and procedural.\nHow memory and knowledge compression work and how it can improve augmented retrieval systems\nIn the last chapter, we explored agent actions using external tools like plugins in the form of native or semantic functions. In this chapter, we look at the role of memory and knowledge using retrieval in agents and chat interfaces. We describe memory and knowledge and how they relate to prompt engineering strategies.\nTo understand memory knowledge, we will investigate document indexing, construct retrieval systems with LangChain, use memory with LangChain, and build semantic memory using Nexus. In the next section, we begin the chapter by exploring retrieval.\n\n\n\n\n\n\nUnderstanding retrieval in AI applications\nRetrieval in agent and chat applications represents a storage mechanism that is typically external and long-lived. Unstructured retrieval can store conversation or task histories, facts, preferences, or other items necessary for contextualizing a prompt. Structured retrieval, typically stored in databases or files, is accessed through native functions or plugins.\nMemory and knowledge, as shown in Figure 8.1, are elements used to add further context and relevant information to a prompt. Prompts can be augmented with everything from information about a document to previous tasks or conversations and other reference information.\n\n [image1.png] \nFigure 8.1 Memory and retrieval and the augmentation of the prompt using the prompt engineering strategies Use External Tools and Provide Reference Text.\nThe prompt engineering strategies shown in Figure 8.1 can be applied to memory and knowledge. Knowledge is not considered memory but rather an augmentation of the prompt from existing documents. Both knowledge and memory use retrieval as the basis for how unstructured information can be queried.\nThe retrieval mechanism, called Retrieval Augmented Generation or RAG, has become a standard for providing relevant context to a prompt. The exact mechanism that powers RAG also powers memory/knowledge, and it is essential to understand how it works. In the next section, we will examine what RAG is.\nBasics of Retrieval Augmented Generation (RAG)\nRAG has become a popular mechanism for supporting document chat or question-and-answer. The system typically works by a user supplying a relevant document like a PDF and then using RAG and an LLM to query the document.\nFigure 8.2 shows how RAG can allow a document to be queried using an LLM. Before any document can be queried, it must first be loaded, transformed into context chunks, embedded into vectors, and stored in a vector database.\n\n [image2.png] \nFigure 8.2 The two phases of RAG: First, documents must be loaded, transformed, embedded, and stored, and then they can be queried using augmented generation.\nA user can query previously indexed documents by submitting a query. That query is then embedded into a vector representation to search for similar chunks in the vector database. Similar content to the query is then used as context and populated into the prompt as augmentation. The prompt is pushed to an LLM, which can use the context information to help answer the query.\nUnstructured memory/knowledge are concepts that rely on some format of text similarity search following the Retrieval pattern shown in Figure 8.2. Figure 8.3 shows how memory uses the same embedding and vector database components. Instead of preloading documents, conversations or parts of a conversation are embedded and saved to a vector database.\n\n [image3.png] \nFigure 8.3 Memory retrieval for augmented generation uses the same embedding patterns to index items to a vector database.\nThe retrieval pattern and document indexing are nuanced and require careful consideration to be employed successfully. This requires understanding how data is stored and retrieved, which we will start to unfold in the next section.\nDelving into Semantic Search and Document Indexing\nDocument indexing transforms a document\'s information to be more easily recovered. How the index will be queried or searched also plays a factor, whether searching for a particular set of words or wanting to match phrase for phrase.\nSemantic search is searching for content that matches the searched phrase by words and meaning. The ability to search by meaning semantically is potent and worth investigating in some detail. In the next section, we look at how vector similarity search can lay the framework for semantic search.\nApplying Vector Similarity Search\nWe will start by seeing how a document can be transformed into a semantic vector, a representation of text that can then be used to perform distance or similarity matching. There are numerous ways to convert text into a semantic vector so that we will look at a simple one.\nOpen the chapter_08 folder in a new VS Code workspace. Create a new environment and pip install the requirements.txt file for all the chapter dependencies. If you need help setting up a new Python environment, consult Appendix B.\nNow open the document_vector_similarity.py file in VS Code and review the top section in Listing 8.1. This example uses TF-IDF, short for Term Frequency-Inverse Document Frequency, which is a numerical statistic that reflects how important a word is to a document in a collection or set of documents by increasing proportionally to the number of times a word appears in the document and offset by the frequency of the word in the document set. TF-IDF is a classic measure of understanding document importance within a set of documents.\nListing 8.1 document_vector_similarity (transform to vector)\nimport plotly.graph_objects as go\nfrom sklearn.feature_extraction.text import TfidfVectorizer\nfrom sklearn.metrics.pairwise import cosine_similarity\n\ndocuments = [    #A\n    "The sky is blue and beautiful.",\n    "Love this blue and beautiful sky!",\n    "The quick brown fox jumps over the lazy dog.",\n    "A king\'s breakfast has sausages, ham, bacon, eggs, toast, and beans",\n    "I love green eggs, ham, sausages and bacon!",\n    "The brown fox is quick and the blue dog is lazy!",\n    "The sky is very blue and the sky is very beautiful today",\n    "The dog is lazy but the brown fox is quick!"\n]\n\nvectorizer = TfidfVectorizer()    #B\nX = vectorizer.fit_transform(documents)    #C\n#A Samples of documents\n#B Vectorization using TF-IDF\n#C Vectorize the documents.\nLet\'s break down TF-IDF into its two components using the example sentence "the sky is blue and beautiful" and focusing on the word "blue":\nTerm Frequency (TF)\n\nTerm Frequency measures how frequently a term occurs in a document. Since we are only considering a single document (our example sentence), the simplest form of the TF for "blue" can be calculated as the number of times "blue" appears in the document divided by the total number of words in the document.\n\nLet\'s calculate it:\n\n    Number of times "blue" appears in the document: 1\n    Total number of words in the document: 6\n\nTF=16TF=61\u200b\nInverse Document Frequency (IDF)\n\nInverse Document Frequency measures how important a term is within the entire corpus. It is calculated by dividing the total number of documents by the number of documents containing the term, and then taking the logarithm of that quotient:\n\nIDF=log\u2061(Total number of documents / Number of documents containing the word)\n\nIDF=log(Number of documents containing the word/Total number of documents\u200b)\n\nIn this example, the corpus is a small collection of 8 documents, and "blue" appears in 4 of these documents.\n\nIDF=log(4/8\u200b)\n\nTF-IDF Calculation\n\nFinally, the TF-IDF score for "blue" in our example sentence is calculated by multiplying the TF and the IDF scores:\n\nTF-IDF=TF×IDF\n\nLet\'s compute the actual values for TF-IDF for the word "blue" using the example provided:\n\nTF=1/6\n\nAssuming the base of the logarithm is 10 (commonly used):\n\nIDF=log10\u200b(8/4\u200b)\n\nNow, let\'s calculate the exact TF-IDF value.\n\nFor the word "blue" in the sentence "the sky is blue and beautiful":\n\n    The Term Frequency (TF) is approximately 0.1670\n    The Inverse Document Frequency (IDF) is approximately 0.301\n    Thus, the TF-IDF score for "blue" is approximately 0.050\n\nThis TF-IDF score indicates the relative importance of the word "blue" in the given document (the example sentence) within the context of the specified corpus (8 documents with "blue" appearing in 4 of them). Higher TF-IDF scores imply greater importance. \u200b\nWe use TF-IDF here because it is simple to apply and understand. Now that we have the elements represented as vectors, we can measure document similarity using cosine similarity. Cosine similarity is a measure used to calculate the cosine of the angle between two non-zero vectors in a multidimensional space, indicating how similar they are, irrespective of their size.\nFigure 8.4 shows how cosine distance compares the vector representations of two pieces or documents of text. Cosine similarity returns a value from -1 (not similar) to 1 (identical). Cosine distance is a normalized value ranging from 0 to 2, derived by taking 1 minus the cosine similarity. A cosine distance of 0 means identical items, and 2 indicates complete opposites.\n\n [image4.png] \nFigure 8.4 How cosine similarity is measured\nListing 8.2 shows how the cosine similarities are computed using the cosine_similarity function from SK-Learn. Similarities are calculated for each document against all the other documents in the set. The computed matrix of similarities for documents is stored in the cosine_similarities variable. Then in the input loop the user can select the document to view its similarities to the other document.\nListing 8.2 document_vector_similarity (cosine similarity)\ncosine_similarities = cosine_similarity(X)    #A\n\nwhile True:    #B\n    selected_document_index = input(f"Enter a document number (0-{len(documents)-1}) or \'exit\' to quit: ").strip()\n\n    if selected_document_index.lower() == \'exit\':\n        break\n\n    if not selected_document_index.isdigit() or not 0 <= int(selected_document_index) < len(documents):\n        print("Invalid input. Please enter a valid document number.")\n        continue\n\n    selected_document_index = int(selected_document_index)    #C\n\n    selected_document_similarities = cosine_similarities[selected_document_index]    #D\n\n# code to plot document similarities omitted\n#A Computes the document similarities for all vector pairs\n#B The main input loop\n#C Gets the selected document index to compare with\n#D Extracts the computed similarities against all documents\nFigure 8.5 shows the output of running the sample in VS Code (F5 for debugging mode). After you select a document, you will see the similarities between the various documents in the set. Note that you won\'t see a negative similarity, because of the TF-IDF vectorization. We will look at other, more sophisticated means of measuring semantic similarity later.\n\n [image5.png] \nFigure 8.5 The cosine similarity between selected document and document set\nThe method of vectorization will dictate the measure of semantic similarity between documents. Before we move on to better methods of vectorizing documents, we will examine storing vectors to perform vector similarity searches in the next section.\nVector Databases and Similarity Search\nAfter vectorizing documents, they can be stored in a vector database for later similarity searches. To demonstrate how this will work, we can efficiently replicate a simple vector database in Python code.\nOpen document_vector_database.py in VS Code, shown in Listing 6.3. This code demonstrates creating a vector database in memory and then allowing users to enter text to search the database and return results. The results returned show the document text and the similarity score.\nListing 6.3 document_vector_database.py\n# code above omitted\nvectorizer = TfidfVectorizer()\nX = vectorizer.fit_transform(documents)\nvector_database = X.toarray()    #A\n\ndef cosine_similarity_search(query, database, vectorizer, top_n=5):    #B\n    query_vec = vectorizer.transform([query]).toarray()\n    similarities = cosine_similarity(query_vec, database)[0]\n    top_indices = np.argsort(-similarities)[:top_n]  # Top n indices\n    return [(idx, similarities[idx]) for idx in top_indices]\n\nwhile True:    #C\n    query = input("Enter a search query (or \'exit\' to stop): ")\n    if query.lower() == \'exit\':\n        break\n    top_n = int(input("How many top matches do you want to see? "))\n    search_results = cosine_similarity_search(query, vector_database, vectorizer, top_n)\n\n    print("Top Matched Documents:")\n    for idx, score in search_results:\n        print(f"- {documents[idx]} (Score: {score:.4f})")    #D\n\n    print("\\n")\n###Output\nEnter a search query (or \'exit\' to stop): blue\nHow many top matches do you want to see? 3\nTop Matched Documents:\n- The sky is blue and beautiful. (Score: 0.4080)\n- Love this blue and beautiful sky! (Score: 0.3439)\n- The brown fox is quick and the blue dog is lazy! (Score: 0.2560)\n#A Stores the document vectors into an array\n#B The function to perform similarity matching on query returns matches and similarity score.\n#C The main input loop\n#D Loops through results and output text and similarity score\nRun this exercise to see the output (F5 in VS Code). Enter any text you like and see the results of documents being returned. This search form works well for matching words and phrases containing similar words and phrases. This form of search misses the word context and meaning from the document. In the next section, we will look at a better way of transforming documents into vectors that better preserves their semantic meaning.\nDemystifying Document Embeddings\nTF-IDF is a simple form that tries to capture semantic meaning in documents. However, it is unreliable because it only counts word frequency and doesn’t understand the relationship between words. A better and more modern method uses document embedding, a form of document vectorizing that better preserves the semantic meaning of the document.\nEmbedding networks are constructed by training neural networks on large datasets to map words, sentences, or documents to high-dimensional vectors, capturing semantic and syntactic relationships based on context and in the data. You typically use a pre-trained model trained on massive datasets to embed documents and perform embeddings. Models are available from many sources, including Hugging Face and, of course, OpenAI.\nIn our next scenario, we will use an OpenAI embedding model. These models are typically perfect for capturing the semantic context of embedded documents. Listing 8.4 shows the relevant code that uses OpenAI to embed the documents into vectors that are then reduced to three dimensions and rendered into a plot.\nListing 8.4 document_visualizing_embeddings.py (showing relevant sections)\nload_dotenv()    #A\napi_key = os.getenv(\'OPENAI_API_KEY\')\nif not api_key:\n    raise ValueError("No API key found. Please check your .env file.")\nclient = OpenAI(api_key=api_key)    #A\n\ndef get_embedding(text, model="text-embedding-ada-002"):    #B\n    text = text.replace("\\n", " ")\n    return client.embeddings.create(input = [text], model=model).data[0].embedding    #B\n\n# Sample documents (omitted)\n\nembeddings = [get_embedding(doc) for doc in documents]    #C\nprint(embeddings_array.shape)\n\nembeddings_array = np.array(embeddings)    #D\n\npca = PCA(n_components=3)    #E\nreduced_embeddings = pca.fit_transform(embeddings_array)\n#A Loads the OpenAI API key and creates a client\n#B Uses the OpenAI client to create the embedding\n#C Generates embeddings for each document of size 1536\n#D Converts embeddings to a numpy array for PCA\n#E Applying PCA to reduce dimensions to 3 for plotting\nWhen a document is embedded using an OpenAI model, it transforms the text into a vector with dimensions of 1536. We cannot visualize this number of dimensions, so we use a dimensionality reduction technique using principal component analysis to convert the vector of size 1536 to 3 dimensions.\nFigure 8.6 shows the output generated from running the file in VS Code. By reducing the embeddings to 3D, we can plot the output to a plot that shows how semantically similar documents are now grouped.\n\n [image6.png] \nFigure 8.6 Embeddings in 3D, showing how similar semantic documents are grouped\nThe choice of what embedding model or service you use is up to you. The OpenAI embedding models are considered the best for general semantic similarity. This has made these models the standard for most memory and retrieval applications.\nWith our understanding of how text can be vectorized with embeddings and stored in a vector database, we can move on to a more realistic example in the next section.\nQuerying Document Embeddings from Chroma\nWe can combine all the pieces and look at a complete example using a local vector database called ChromaDb. Many vector database options exist, but ChromaDb is an excellent local vector store for development or small-scale projects. There are also plenty of more robust options that you can consider later.\nListing 8.5 shows the new and relevant code sections from the document_query_chromadb.py file. Note, the results are scored by distance and not similarity. Cosine distance is determined by the equation below:\nCosine\xa0Distance(A,B)=1−Cosine\xa0Similarity(A,B)\nThis means that cosine distance will range from 0 for most similar to 2 for being semantically opposite in meaning.\n \nListing 8.5 document_query_chromadb.py (relevant code sections)\nembeddings = [get_embedding(doc) for doc in documents]    #A\nids = [f"id{i}" for i in range(len(documents))]    #A\n\nchroma_client = chromadb.Client()    #B\ncollection = chroma_client.create_collection(name="documents")    #B\ncollection.add(    #C\n    embeddings=embeddings,\n    documents=documents,\n    ids=ids\n)\n\ndef query_chromadb(query, top_n=2):    #D\n    query_embedding = get_embedding(query)\n    results = collection.query(\n        query_embeddings=[query_embedding],\n        n_results=top_n\n    )\n    return [(id, score, text) for id, score, text in\n            zip(results[\'ids\'][0], results[\'distances\'][0], results[\'documents\'][0])]\n\nwhile True:    #E\n    query = input("Enter a search query (or \'exit\' to stop): ")\n    if query.lower() == \'exit\':\n        break\n    top_n = int(input("How many top matches do you want to see? "))\n    search_results = query_chromadb(query, top_n)\n\n    print("Top Matched Documents:")\n    for id, score, text in search_results:\n        print(f"ID:{id} TEXT: {text} SCORE: {round(score, 2)}")    #E\n\n    print("\\n")\n###Output\nEnter a search query (or \'exit\' to stop): dogs are lazy\nHow many top matches do you want to see? 3\nTop Matched Documents:\nID:id7 TEXT: The dog is lazy but the brown fox is quick! SCORE: 0.24\nID:id5 TEXT: The brown fox is quick and the blue dog is lazy! SCORE: 0.28\nID:id2 TEXT: The quick brown fox jumps over the lazy dog. SCORE: 0.29\n#A Generates embeddings for each document and assigns an Id\n#B Creates Chroma database client and creates a collection\n#C Adds document embeddings to the collection\n#D Queries the datastore and returns top n relevant documents\n#E The input loop for user input and output of relevant documents/scores\nAs the earlier scenario demonstrated, you can now query the documents using semantic meaning rather than just key terms or phrases. These scenarios should now provide the background to see how the retrieval pattern works at a low level. In the next section we will see how the retrieval pattern can be employed using LangChain.\nConstructing RAG with LangChain\nLangChain began as an open-source project specializing in abstracting the retrieval pattern across multiple data sources and vector stores. It has since morphed into much more, but foundationally, it still provides excellent options for implementing retrieval.\nFigure 8.7 shows a diagram from LangChain that identifies the process of storing documents for retrieval. These same steps may be replicated in whole or in part to implement memory retrieval. The critical difference between document and memory retrieval is the source and how content is transformed.\n\n [image7.png] \nFigure 8.7 Load, transform, embed, and store steps in storing documents for later retrieval\nWe will examine how to implement each of these steps using LangChain and understand the nuances and details accompanying this implementation. In the next section, we will start by loading and splitting documents with LangChain.\nSplitting and Loading Documents with LangChain\nRetrieval mechanisms augment the context of a given prompt with specific information relevant to the request. For example, you may want to request detailed information about a local document. With earlier language models, submitting the whole document as part of the prompt wasn\'t an option due to token limitations.\nToday, we could submit a whole document for many commercial LLMs like GPT-4-Turbo as part of a prompt request. However, the results may not be better and would likely cost more because of the increased number of tokens. Therefore, a better option is to split the document and use the relevant parts to request context—precisely what RAG and memory do.\nSplitting a document is essential in breaking down content into semantically and specifically relevant sections. Figure 8.8 shows how to break down an HTML document containing the Mother Goose nursery rhymes. Often, splitting a document into contextual semantic chunks requires careful consideration.\n\n [image8.png] \nFigure 8.8 How the document would ideally be split into chunks for better semantic and contextual meaning\nIdeally, when we split documents into chunks, they are broken down by relevance and semantic meaning. While an LLM or agent could help us with this, we will look at current toolkit options within LangChain for splitting documents. Later in this chapter, we will look at a semantic function that can assist us in semantically dividing content for embeddings.\nFor the next exercise, open langchain_load_splitting.py in VS Code, Listing 6.6. This code shows where we left off from Listing 8.5, in the last section. Instead of using the sample documents, we are loading the Mother Goose nursery rhymes this time.\nListing 6.6 langchain_load_splitting.py (relevant sections and output)\nfrom langchain.document_loaders import UnstructuredHTMLLoader    #A\nfrom langchain.text_splitter import RecursiveCharacterTextSplitter\n\n#previous code\n\nloader = UnstructuredHTMLLoader("sample_documents/mother_goose.html")    #B\ndata = loader.load    #C\n\ntext_splitter = RecursiveCharacterTextSplitter(\n    chunk_size=100,\n    chunk_overlap=25,    #D\n    length_function=len,\n    add_start_index=True,\n)\ndocuments = text_splitter.split_documents(data)\n\ndocuments = [doc.page_content for doc in documents] [100:350]    #E\n\nembeddings = [get_embedding(doc) for doc in documents]    #F\nids = [f"id{i}" for i in range(len(documents))]\n###Output\nEnter a search query (or \'exit\' to stop): who kissed the girls and made them cry?\nHow many top matches do you want to see? 3\nTop Matched Documents:\nID:id233 TEXT: And chid her daughter,\n        And kissed my sister instead of me. SCORE: 0.4…\n#A New LangChain imports\n#B Loads the document as HTML\n#C Loads the document\n#D Splits the document into blocks of text 100 characters long with 25-character overlap\n#E Embeds only 250 chunks, which is cheaper and faster\n#F Returns the embedding for each document\nNote in Listing 8.6 that the HTML document gets split into 100-character chunks with a 25-character overlap. The overlap allows the document\'s parts not to cut off specific thoughts. We selected the splitter for this exercise because it was easy to use, set up, and understand.\nGo ahead and run the langchain_load_splitting.py file in VS Code (F5). Enter a query and see what results you get. The output in Listing 5.6 shows good results given a specific example. Remember that we only embed 250 document chunks to reduce costs and keep the exercise short. Of course, you can always try to embed the entire document or use a minor input document example.\nPerhaps the most critical element to building proper retrieval is the process of document splitting. You can use numerous methods to split a document, including multiple concurrent methods. More than one method passes and splits the document for numerous embedding views of the same document.\nIn the next section, we will examine a more general technique for splitting documents using tokens and tokenization.\nSplitting Documents by Token with LangChain\nTokenization is the process of breaking text into word tokens. Where a word token represents a succinct element in the text, a token could be a word like hold or even a symbol like the left curly brace ({), depending on what is relevant.\nSplitting documents using tokenization provides a better base for how the text will be interpreted by language models and for semantic similarity. Tokenization also allows the removal of irrelevant characters, such as whitespace, making the similarity matching of documents more relevant and generally providing better results.\nFor the next code exercise, open the langchain_token_splitting.py file in VS Code as shown in Listing 8.7. Now we split the document using tokenization, which breaks the document into sections of unequal size. The unequal size results from the large sections of whitespace the original document has.\nListing 6.7 langchain_token_splitting.py (relevant new code)\nloader = UnstructuredHTMLLoader("sample_documents/mother_goose.html")\ndata = loader.load()\ntext_splitter = CharacterTextSplitter.from_tiktoken_encoder(\n    chunk_size=50, chunk_overlap=10    #A\n)\n\ndocuments = text_splitter.split_documents(data)\ndocuments = [doc for doc in documents][8:94]    #B\n\ndb = Chroma.from_documents(documents, OpenAIEmbeddings())\n\ndef query_documents(query, top_n=2):\n    docs = db.similarity_search(query, top_n)    #C\n    return docs\n###Output\nCreated a chunk of size 68, which is longer than the specified 50\nCreated a chunk of size 67, which is longer than the specified 50    #D\nEnter a search query (or \'exit\' to stop): who kissed the girls and made them cry?\nHow many top matches do you want to see? 3\nTop Matched Documents:\nDocument 1: GEORGY PORGY\n\n        Georgy Porgy, pudding and pie,\n        Kissed the girls and made them cry.\n#A Update to 50 tokens and overlap of 10 tokens\n#B Selects just the documents that contain rhymes\n#C Uses the database\'s similarity search\n#D Breaks into irregular size chunks because of the white space\nRun the langchain_token_splitting.py code in VS Code (F5). You can use the query we used last time or your own. Notice how the results are significantly better than the previous exercise. However, the results are still suspect since the query uses several similar words in the same order.\nA better test would be to try a semantically similar phrase but one that uses different words and see the results. With the code still running, enter a new phrase to query: "Why are the girls crying?" Listing 6.8 shows the results of executing that query. If you run this example yourself and scroll down over the output, you will see Georgy Porgy appear in either the second or third returned document.\nListing 6.8 query -> Why are the girls crying?\nEnter a search query (or \'exit\' to stop): Who made the girls cry?\nHow many top matches do you want to see? 3\nTop Matched Documents:\nDocument 1: WILLY, WILLY\n\n        Willy, Willy Wilkin…\nThis exercise shows how various retrieval methods can be employed to return documents semantically.  With this base established, we can see how RAG can be applied to knowledge and memory systems.  The following section will discuss RAG as it applies to knowledge of agents and agentic systems.\nApplying RAG to building agent knowledge\nKnowledge in agents encompasses employing RAG to search semantically across unstructured documents. These documents could be anything from PDFs to Word documents and all text, including code. Agentic knowledge also includes using unstructured documents for Q&A, reference lookup, information augmentation, and other future patterns.\nNexus, the agent platform developed in tandem with this book and introduced in the last chapter, employs complete knowledge and memory systems for agents. In this section, we will uncover how the knowledge system works.\nTo install Nexus for just this chapter, refer to Listing 8.9. Open a terminal within the chapter_08 folder and execute the commands in the listing to download, install, and run Nexus in normal or development mode. If you want to refer to the code, you should install the project in development and configure the debugger to run the Streamlit app from VS Code. Refer to Chapter 7 if you need to refresh any of these steps.\nListing 8.9 Installing Nexus \n# to install and run\npip install git+https://github.com/cxbxmxcx/Nexus.git\n\nnexus run\n# install in development mode\ngit clone https://github.com/cxbxmxcx/Nexus.git\n\n# Install the cloned repository in editable mode\npip install -e Nexus\nRegardless of which method you decide to run the app in after you log in, navigate to the Knowledge Store page, as shown in Figure 8.9. Create a new Knowledge Store and then upload the sample_documents/back_to_the_future.txt movie script. \n\n [image9.png] \nFigure 8.9 adding a new knowledge store and populating it with a document\nThe script is a large document, and it may take a while to load, chunk, and embed the parts into the vector database ChromaDB. Wait for the indexing to complete, and then you can inspect the embeddings and run a query, as shown in Figure 8.10.\n\n [image10.png] \nFigure 8.10 shows the embeddings and document query views\nNow we can connect the knowledge store to a supported agent and ask questions. Use the top left selector to choose the chat page within the Nexus interface. Then, select an agent and the time_travel knowledge store, as shown in Figure 8.11. You will also need to select an agent engine that supports knowledge. Each of the multiple agent engines requires the proper configuration to be accessbile. If you want to see how to configure more agents consult Appendix C.\n\n [image11.png] \nFigure 8.11 enabling the knowledge store for agent use\nCurrently, as of this chapter, Nexus only supports access to a single knowledge store at a time. In a future version, agents may be able to select multiple knowledge stores at a time. This may include more advanced options, from semantic knowledge to employing other forms of RAG.\nYou can also configure the RAG settings within the configuration tab of the Knowledge Store page as shown in Figure 8.12. As of now you can select from the type of splitter to chunk the document and the size and any overlap. \n\n [image12.png] \nFigure 8.12 managing the knowledge store splitting and chunking options\nThe loading, splitting, chunking, and embedding options provided are the only basic options supported by LangChain for now. In future versions of Nexus, more options and patterns will be offered. The code to support other options can be added directly to Nexus.\nWe won’t cover the code that performs the RAG as it is very similar to what we already covered. Feel free to review the Nexus code, \n.\nparticularly the KnowledgeManager class in the knowledge_manager.py file. \nWhile the retrieval patterns for knowledge and memory are quite similar for augmentation, the two patterns differ when it comes to populating the stores. In the next section, we will explore what makes memory in agents unique.\nImplementing memory in agentic systems\nMemory in agents and GPT applications is often described in the same terms as cognitive memory functions. Cognitive memory describes the type of memory animals use to remember what we did 30 seconds ago or how tall we were 30 years ago. Computer memory is also an essential element of agent memory, but one we won’t consider in this section.\nFigure 8.13 shows how memory is broken down into sensory, short-term, and long-term memory. This memory can be applied to GPT agents, and this list describes how each form of memory maps to agent functions:\nSensory Memory in GPT: Functions like retrieval augmented generation but with images/audio/haptic data forms. Briefly hold input data (text, images, etc.) for immediate processing but not long-term storage. Visual memory is a growing concept we will explore in Chapter 11.\nShort-Term/Working Memory in GPT: Acts as an active memory buffer of conversation history. We are holding a limited amount of recent input and context for immediate analysis and response generation. Within Nexus short- and long-term conversational memory is also held within the context of thread.\nLong-Term Memory in GPT: Longer-term memory storage relevant to the agent\'s or user\'s life. Semantic memory provides a robust capacity to store and retrieve relevant global or local facts and concepts. \n\n [image13.png] \nFigure 8.13 How memory is broken down into various forms\nWhile memory uses the exact retrieval and augmentation mechanisms as knowledge, it typically differs significantly when updating or appending memories. Figure 6.14 highlights the process of capturing and using memories to augment prompts. Since memories are often different from the size of complete documents, we can avoid using any splitting or chunking mechanisms.\n\n [image14.png] \nFigure 8.14 basic memory retrieval and augmentation workflow\nNexus provides a mechanism like the knowledge store, allowing users to create memory stores that can be configured for different uses and applications. It also supports some of the more advanced memory forms highlighted in Figure 8.13. The following section will examine how basic memory stores work in Nexus.\nConsuming memory stores in Nexus\nMemory stores operate and are constructed like knowledge stores within Nexus. They both heavily rely on the retrieval pattern. What differs is the extra steps memory systems take to build new memories.\nGo ahead and start Nexus and refer to Listing 8.9 if you need to install it. After logging in, select the Memory page and create a new memory store, as shown in Figure 8.15. Select an agent engine and then add a few personal facts and preferences about yourself.\n\n [image15.png] \nFigure 8.15 adding memories to a newly created memory store\nThe reason we need an agent (LLM) is shown in Figure 8.14. When information is fed into a memory store is generally processed through an LLM using something called a Memory Function. The purpose of the Memory Function is to process the statements/conversations into semantically relevant information related to the type of memory.\nListing 8.10 shows the conversational memory function used to extract information from a conversation into memories. Yes, this is just the header portion of the prompt sent to the LLM, instructing it how to extract information from a conversation. \nListing 8.10 Conversational Memory Function\nSummarize the conversation and create a set of statements that summarize the conversation. Return a JSON object with the following keys: \'summary\'. Each key should have a list of statements that are relevant to that category. Return only the JSON object and nothing else.\nAfter you generate a few relevant memories about yourself, return to the Chat area in Nexus enable the my_memory memory store, and see how well the agent knows you. Figure 8.16 shows an example conversation using a different agent engine. Consult Appendix C if you need information on configuring more agent engine types.\n\n [image16.png] \nFigure 8.16 shows conversing with a different agent on the same memory store\nThis is an example of a basic memory pattern that extracts facts/preferences from conversations and stores them in a vector database as memories. Numerous other implements of memory follow those displayed in Figure 8.13. We will implement those in the next section.\nSemantic memory and applications to semantic, episodic, and procedural memory\nPsychologists categorize memory into multiple forms, depending on what information is remembered. Semantic, episodic, and procedural memory all represent different types of information. Episodic memories are about events, procedural memories of the process or steps, semantic represent the meaning, and could include feelings or emotions. Other forms of memory, geospatial being another, are not described here but could be. \nBecause these memories rely on an additional level of categorization, they also rely on another level of semantic categorization. Some platforms, like Semantic Kernel, refer to this as semantic memory. This can be confusing because semantic categorization is also applied to extract episodic and procedural memories.\nFigure 8.17 shows the semantic memory categorization process, also sometimes called semantic memory. The difference between semantic memory and regular memory is the additional step of processing the input semantically and extracting relevant questions that can be used to query the memory-relevant vector database.\n\n\n [image17.png] \nFigure 8.17 shows how semantic memory augmentation works\nThe benefit of using semantic augmentation is the increased ability to extract more relevant memories. We can see this in operation by jumping back into Nexus and creating a new semantic memory store.\nFigure 8.18 shows how to configure a new memory store using semantic memory. As of yet, you cannot configure the specific function prompts for memory, augmentation, and summarization. However, it can be useful to read through each of the function prompts and get a sense for how they work.\n\n\n [image18.png] \nFigure 8.18 shows configuration for changing the memory store type to semantic\nNow, if you go back and add facts and preferences, they will convert to the semantics of the relevant memory type. Figure 8.19 shows an example of memories being populated for the same set of statements into two different forms of memory. Generally, the statements entered memory would be more specific to the form of memory.\n\n [image19.png] \nFigure 8.19 compares memories for the same information given two different memory types\nMemory and knowledge can significantly assist an agent with various application types. Indeed, a single memory/knowledge store could feed one or multiple agents, allowing for further specialized interpretations of both types of stores. Throughout this book, we will explore various other forms of memory, knowledge, and architecture. Before we get to that, though, we will finish out the chapter discussing memory/knowledge compression in the next section.\nUnderstanding memory and knowledge compression\nMuch like our own memory, memory stores can become cluttered with redundant information and numerous unrelated details over time. Internally, our minds deal with memory clutter by compressing or summarizing memories. Our minds remember more significant details over less important ones or memories accessed more frequently.\nWe can apply similar principles of memory compression to agent memory and other retrieval systems to extract significant details. The principle of compression is similar to semantic augmentation but adds another layer to the pre-clusters groups of related memories that can collectively be summarized.\nFigure 8.20 shows the process of memory/knowledge compression. Memories or knowledge are first clustered using an algorithm like K-Means. Then, the groups of memories are passed through a compression function, which summarizes and collects the items into more succinct representations. \n\n [image20.png] \nFigure 8.20 shows the process of memory and knowledge compression\nGPT Nexus provides for both knowledge and memory store compression using K-Means optimal clustering. Figure 8.21 shows the compression interface for memory. Within the compression interface, you will see the items displayed in 3D and clustered. The size of the clusters is shown in the left table.\n\n [image21.png] \nFigure 8.21 shows the interface for compressing memories\nCompressing memories and even knowledge is generally recommended if the number of items in a cluster is large or unbalanced. Each use case for compression may vary depending on the use and application of memories. Generally, though, if an inspection of the items in a store contains repetitive or duplicate information, it is a good time for compression. \nBelow is a summary of other cases that discuss the suggested applications and use of compression.\nThe case for Knowledge compression\nKnowledge retrieval and augmentation have also been shown to benefit significantly from compression. Results will vary by use case, but generally, the more verbose the source of knowledge, the more it will benefit from compression. Documents that feature literary prose, such as stories and novels, will benefit more than, say, a base of code. However, if the code is likewise very repetitive, it could also be shown to be beneficial.\nThe case for how often do you apply compression\nMemory will often benefit from the periodic compression application, whereas knowledge stores typically only help on the first load. How frequently you apply compression will greatly depend on the memory use, how often, and by how many. We will review a process for automatically applying compression in a later chapter.\nThe case for applying compression more than once\nIt has also been shown that multiple passes of compression at the same time can, in fact, improve retrieval performance. Other patterns have also suggested using memory or knowledge at various levels of compression. For example, a knowledge store is compressed two times, resulting in 3 different levels of knowledge at different levels. \nThe case for blending knowledge and memory compression\nIf a system is specialized to a particular source of knowledge and it also employs memories, there may be further optimization to consolidate stores. Another approach is to populate memory with the starting knowledge of a document directly.\nThe case for multiple memory or knowledge stores\nIn more advanced systems, we will look at agents employing multiple memory and knowledge stores relevant to their workflow. For example, an agent could employ individual memory stores as part of its conversations with individual users, perhaps including the ability to share different groups of memory with different groups of individuals.\nMemory and knowledge retrieval are cornerstones of agentic systems, and later in this book, we will cover various other uses and applications. That being said, our chapter is over and we can now summarize what we covered and review some learning exercises in the next section.\nSummary\nMemory in AI Applications differentiates between unstructured and structured memory, highlighting their use in contextualizing prompts for more relevant interactions.\nRetrieval-augmented generation (RAG) is a mechanism for enhancing prompts with context from external documents, utilizing vector embeddings and similarity search to retrieve relevant content.\nSemantic Search and Document Indexing converts documents into semantic vectors using TF-IDF and cosine similarity, enhancing the capability to perform semantic searches across indexed documents.\nVector Databases and Similarity Search stores document vectors in a vector database, facilitating efficient similarity searches and improving retrieval accuracy.\nDocument Embeddings capture semantic meanings, leveraging models like OpenAI\'s to generate embeddings that preserve a document\'s context and facilitate semantic similarity searches.\nLangChain provides several tools for performing RAG, and it abstracts the retrieval process, allowing for easy implementation of RAG and memory systems across various data sources and vector stores.\nShort-term and Long-term Memory in LangChain implements conversational memory within LangChain, distinguishing between short-term buffering patterns and long-term storage solutions.\nStoring document vectors in databases for efficient similarity searches is crucial for implementing scalable retrieval systems in AI applications.\nAgent knowledge directly relates to the general RAG pattern of performing question and answer on documents or other textual information.\nAgent memory is a pattern related to RAG that captures the agentic interactions with users, itself, and other systems.\nNexus is a platform that implements agentic knowledge and memory systems, including setting up knowledge stores for document retrieval and memory stores for various forms of memory.\nSemantic memory augmentation (Semantic Memory) differentiates between various types of memories (semantic, episodic, procedural). It implements them through semantic augmentation, enhancing agents\' ability to recall and use information relevantly specific to the nature of the memories.\nMemory and Knowledge Compression are techniques for condensing information stored in memory and knowledge systems, improving retrieval efficiency and relevancy through clustering and summarization.\nExercises\nUse the following exercises to improve your knowledge of the material:\nExercise 1: Load and Split a Different Document (Intermediate) \nObjective: Understand the impact of document splitting on retrieval efficiency by using LangChain. \nTask:\nSelect a different document (e.g., a news article, a scientific paper, or a short story).\nUse LangChain to load and split the document into chunks.\nAnalyze how the document is split into chunks and how it affects the retrieval process.\nExercise 2: Experiment with Semantic Search (Intermediate) \nObjective: Compare the effectiveness of various vectorization techniques by performing semantic searches. \nTask:\nChoose a set of documents for semantic search.\nUse a vectorization method such as Word2Vec or BERT embeddings instead of TF-IDF.\nPerform the semantic search and compare the results with those obtained using TF-IDF to understand the differences and effectiveness.\nExercise 3: Implement a Custom RAG Workflow (Advanced) \nObjective: Apply theoretical knowledge of RAG in a practical context using LangChain. \nTask:\nChoose a specific application (e.g., customer service inquiries or academic research queries).\nDesign and implement a custom RAG workflow using LangChain.\nTailor the workflow to suit the chosen application and test its effectiveness.\nExercise 4: Build a Knowledge Store and Experiment with Splitting Patterns (Intermediate) \nObjective: Understand how different splitting patterns and compression affect knowledge retrieval. \nTask:\nBuild a knowledge store and populate it with a couple of documents.\nExperiment with different forms of splitting/chunking patterns and analyze their impact on retrieval.\nCompress the knowledge store and observe the effects on query performance.\nExercise 5: Build and Test Various Memory Stores (Advanced) \nObjective: Understand the uniqueness and use cases of different memory store types. Task:\nBuild various forms of memory stores (conversational, semantic, episodic, and procedural).\nInteract with an agent using each type of memory store and observe the differences.\nCompress the memory store and analyze the effect on memory retrieval.\n', ['G:\\My Drive\\Blog\\blog_1_1\\images\\image1.png', 'G:\\My Drive\\Blog\\blog_1_1\\images\\image3.png', 'G:\\My Drive\\Blog\\blog_1_1\\images\\image4.png', 'G:\\My Drive\\Blog\\blog_1_1\\images\\image5.png', 'G:\\My Drive\\Blog\\blog_1_1\\images\\image6.png', 'G:\\My Drive\\Blog\\blog_1_1\\images\\image7.png', 'G:\\My Drive\\Blog\\blog_1_1\\images\\image8.png', 'G:\\My Drive\\Blog\\blog_1_1\\images\\image9.png', 'G:\\My Drive\\Blog\\blog_1_1\\images\\image10.png', 'G:\\My Drive\\Blog\\blog_1_1\\images\\image11.png', 'G:\\My Drive\\Blog\\blog_1_1\\images\\image12.png', 'G:\\My Drive\\Blog\\blog_1_1\\images\\image13.png', 'G:\\My Drive\\Blog\\blog_1_1\\images\\image2.png', 'G:\\My Drive\\Blog\\blog_1_1\\images\\image15.png', 'G:\\My Drive\\Blog\\blog_1_1\\images\\image16.png', 'G:\\My Drive\\Blog\\blog_1_1\\images\\image17.png', 'G:\\My Drive\\Blog\\blog_1_1\\images\\image18.png', 'G:\\My Drive\\Blog\\blog_1_1\\images\\image19.png', 'G:\\My Drive\\Blog\\blog_1_1\\images\\image20.png', 'G:\\My Drive\\Blog\\blog_1_1\\images\\image21.png', 'G:\\My Drive\\Blog\\blog_1_1\\images\\image14.png'], [])
assistant > action: create_word_doc -> {'name': 'create_word_doc', 'group': 'word_actions', 'pointer': <function create_word_doc at 0x00000257901B9000>, 'agent_action': {'type': 'function', 'function': {'name': 'create_word_doc', 'description': '\n    Create a new Word document.\n\n    Parameters:\n    doc_filename (str): The path to the Word document.\n    ', 'parameters': {'type': 'object', 'properties': {'doc_filename': {'type': 'string', 'description': 'doc_filename'}}, 'required': ['doc_filename']}}}, 'prompt_template': None}
action: create_word_doc -> {'doc_filename': 'understanding_retrieval_in_agentic_systems_blog.docx'}
action: create_word_doc(args={"doc_filename":"understanding_retrieval_in_agentic_systems_blog.docx"}) -> Document created successfully.
action: append_paragraph_to_word_doc -> {'name': 'append_paragraph_to_word_doc', 'group': 'word_actions', 'pointer': <function append_paragraph_to_word_doc at 0x00000257901B9990>, 'agent_action': {'type': 'function', 'function': {'name': 'append_paragraph_to_word_doc', 'description': '\n    Append a paragraph to a Word document.\n\n    Parameters:\n    doc_filename (str): The path to the Word document.\n    paragraph_text (str): The text to append as a paragraph.\n    ', 'parameters': {'type': 'object', 'properties': {'doc_filename': {'type': 'string', 'description': 'doc_filename'}, 'paragraph_text': {'type': 'string', 'description': 'paragraph_text'}}, 'required': ['doc_filename', 'paragraph_text']}}}, 'prompt_template': None}
action: append_paragraph_to_word_doc -> {'doc_filename': 'understanding_retrieval_in_agentic_systems_blog.docx', 'paragraph_text': 'The field of Artificial Intelligence is growing by leaps and bounds, like a young sapling straining towards the sun. One of its most exciting branches is the development of agentic systems—agents infused with memory and knowledge that can interact more naturally and effectively with us. Let’s delve into how retrieval plays a key role in making these systems tick.'}
action: append_paragraph_to_word_doc(args={"doc_filename": "understanding_retrieval_in_agentic_systems_blog.docx", "paragraph_text": "The field of Artificial Intelligence is growing by leaps and bounds, like a young sapling straining towards the sun. One of its most exciting branches is the development of agentic systems—agents infused with memory and knowledge that can interact more naturally and effectively with us. Let’s delve into how retrieval plays a key role in making these systems tick."}) -> Paragraph added successfully.
action: append_image_to_word_doc -> {'name': 'append_image_to_word_doc', 'group': 'word_actions', 'pointer': <function append_image_to_word_doc at 0x00000257901BAD40>, 'agent_action': {'type': 'function', 'function': {'name': 'append_image_to_word_doc', 'description': '\n    Append an image with a caption to a Word document.\n\n    Parameters:\n    doc_filename (str): The path to the Word document.\n    image_filename (str): The path to the image file to append.\n    caption_text (str): The caption text to append below the image.\n    ', 'parameters': {'type': 'object', 'properties': {'doc_filename': {'type': 'string', 'description': 'doc_filename'}, 'image_filename': {'type': 'string', 'description': 'image_filename'}, 'caption_text': {'type': 'string', 'description': 'caption_text'}}, 'required': ['doc_filename', 'image_filename', 'caption_text']}}}, 'prompt_template': None}
action: append_image_to_word_doc -> {'doc_filename': 'understanding_retrieval_in_agentic_systems_blog.docx', 'image_filename': 'images/image1.png', 'caption_text': 'Understanding Retrieval'}
action: append_image_to_word_doc(args={"doc_filename": "understanding_retrieval_in_agentic_systems_blog.docx", "image_filename": "images/image1.png", "caption_text": "Understanding Retrieval"}) -> Image added successfully.
action: append_heading_to_word_doc -> {'name': 'append_heading_to_word_doc', 'group': 'word_actions', 'pointer': <function append_heading_to_word_doc at 0x00000257901BA320>, 'agent_action': {'type': 'function', 'function': {'name': 'append_heading_to_word_doc', 'description': '\n    Append a heading to a Word document.\n\n    Parameters:\n    doc_filename (str): The path to the Word document.\n    heading_text (str): The text to append as a heading.\n    level (int): The heading level (0-9).\n    ', 'parameters': {'type': 'object', 'properties': {'doc_filename': {'type': 'string', 'description': 'doc_filename'}, 'heading_text': {'type': 'string', 'description': 'heading_text'}, 'level': {'type': 'string', 'description': 'level'}}, 'required': ['doc_filename', 'heading_text', 'level']}}}, 'prompt_template': None}
action: append_heading_to_word_doc -> {'doc_filename': 'understanding_retrieval_in_agentic_systems_blog.docx', 'heading_text': 'Introduction', 'level': '1'}
action: append_heading_to_word_doc(args={"doc_filename": "understanding_retrieval_in_agentic_systems_blog.docx", "heading_text": "Introduction", "level": "1"}) -> Heading added successfully.
action: append_paragraph_to_word_doc -> {'name': 'append_paragraph_to_word_doc', 'group': 'word_actions', 'pointer': <function append_paragraph_to_word_doc at 0x00000257901B9990>, 'agent_action': {'type': 'function', 'function': {'name': 'append_paragraph_to_word_doc', 'description': '\n    Append a paragraph to a Word document.\n\n    Parameters:\n    doc_filename (str): The path to the Word document.\n    paragraph_text (str): The text to append as a paragraph.\n    ', 'parameters': {'type': 'object', 'properties': {'doc_filename': {'type': 'string', 'description': 'doc_filename'}, 'paragraph_text': {'type': 'string', 'description': 'paragraph_text'}}, 'required': ['doc_filename', 'paragraph_text']}}}, 'prompt_template': None}
action: append_paragraph_to_word_doc -> {'doc_filename': 'understanding_retrieval_in_agentic_systems_blog.docx', 'paragraph_text': "In our ever-evolving world of AI, the ability to retrieve information is foundational. Whether it's about drawing from vast databases or pulling snippets of past interactions, retrieval shapes the context and enhances the capability of AI systems. This journey will cover retrieval across semantic search, document indexing, and the intricacies of retrieval-augmented generation (RAG) workflows."}
action: append_paragraph_to_word_doc(args={"doc_filename": "understanding_retrieval_in_agentic_systems_blog.docx", "paragraph_text": "In our ever-evolving world of AI, the ability to retrieve information is foundational. Whether it's about drawing from vast databases or pulling snippets of past interactions, retrieval shapes the context and enhances the capability of AI systems. This journey will cover retrieval across semantic search, document indexing, and the intricacies of retrieval-augmented generation (RAG) workflows."}) -> Paragraph added successfully.
action: append_image_to_word_doc -> {'name': 'append_image_to_word_doc', 'group': 'word_actions', 'pointer': <function append_image_to_word_doc at 0x00000257901BAD40>, 'agent_action': {'type': 'function', 'function': {'name': 'append_image_to_word_doc', 'description': '\n    Append an image with a caption to a Word document.\n\n    Parameters:\n    doc_filename (str): The path to the Word document.\n    image_filename (str): The path to the image file to append.\n    caption_text (str): The caption text to append below the image.\n    ', 'parameters': {'type': 'object', 'properties': {'doc_filename': {'type': 'string', 'description': 'doc_filename'}, 'image_filename': {'type': 'string', 'description': 'image_filename'}, 'caption_text': {'type': 'string', 'description': 'caption_text'}}, 'required': ['doc_filename', 'image_filename', 'caption_text']}}}, 'prompt_template': None}
action: append_image_to_word_doc -> {'doc_filename': 'understanding_retrieval_in_agentic_systems_blog.docx', 'image_filename': 'images/image3.png', 'caption_text': 'Memory and retrieval in AI'}
action: append_image_to_word_doc(args={"doc_filename": "understanding_retrieval_in_agentic_systems_blog.docx", "image_filename": "images/image3.png", "caption_text": "Memory and retrieval in AI"}) -> Image added successfully.
action: append_heading_to_word_doc -> {'name': 'append_heading_to_word_doc', 'group': 'word_actions', 'pointer': <function append_heading_to_word_doc at 0x00000257901BA320>, 'agent_action': {'type': 'function', 'function': {'name': 'append_heading_to_word_doc', 'description': '\n    Append a heading to a Word document.\n\n    Parameters:\n    doc_filename (str): The path to the Word document.\n    heading_text (str): The text to append as a heading.\n    level (int): The heading level (0-9).\n    ', 'parameters': {'type': 'object', 'properties': {'doc_filename': {'type': 'string', 'description': 'doc_filename'}, 'heading_text': {'type': 'string', 'description': 'heading_text'}, 'level': {'type': 'string', 'description': 'level'}}, 'required': ['doc_filename', 'heading_text', 'level']}}}, 'prompt_template': None}
action: append_heading_to_word_doc -> {'doc_filename': 'understanding_retrieval_in_agentic_systems_blog.docx', 'heading_text': 'Basics of Retrieval Augmented Generation (RAG)', 'level': '1'}
action: append_heading_to_word_doc(args={"doc_filename": "understanding_retrieval_in_agentic_systems_blog.docx", "heading_text": "Basics of Retrieval Augmented Generation (RAG)", "level": "1"}) -> Heading added successfully.
action: append_paragraph_to_word_doc -> {'name': 'append_paragraph_to_word_doc', 'group': 'word_actions', 'pointer': <function append_paragraph_to_word_doc at 0x00000257901B9990>, 'agent_action': {'type': 'function', 'function': {'name': 'append_paragraph_to_word_doc', 'description': '\n    Append a paragraph to a Word document.\n\n    Parameters:\n    doc_filename (str): The path to the Word document.\n    paragraph_text (str): The text to append as a paragraph.\n    ', 'parameters': {'type': 'object', 'properties': {'doc_filename': {'type': 'string', 'description': 'doc_filename'}, 'paragraph_text': {'type': 'string', 'description': 'paragraph_text'}}, 'required': ['doc_filename', 'paragraph_text']}}}, 'prompt_template': None}
action: append_paragraph_to_word_doc -> {'doc_filename': 'understanding_retrieval_in_agentic_systems_blog.docx', 'paragraph_text': 'When you ask a question to a sophisticated AI system, the RAG mechanism swings into action. It takes your query, dives into preloaded documents, transforms them into context chunks, embeds them into vectors, and stores them in a vector database. When you query again, it compares the query with these stored vectors and pulls the most relevant chunks to form an answer.'}
action: append_paragraph_to_word_doc(args={"doc_filename": "understanding_retrieval_in_agentic_systems_blog.docx", "paragraph_text": "When you ask a question to a sophisticated AI system, the RAG mechanism swings into action. It takes your query, dives into preloaded documents, transforms them into context chunks, embeds them into vectors, and stores them in a vector database. When you query again, it compares the query with these stored vectors and pulls the most relevant chunks to form an answer."}) -> Paragraph added successfully.
action: append_image_to_word_doc -> {'name': 'append_image_to_word_doc', 'group': 'word_actions', 'pointer': <function append_image_to_word_doc at 0x00000257901BAD40>, 'agent_action': {'type': 'function', 'function': {'name': 'append_image_to_word_doc', 'description': '\n    Append an image with a caption to a Word document.\n\n    Parameters:\n    doc_filename (str): The path to the Word document.\n    image_filename (str): The path to the image file to append.\n    caption_text (str): The caption text to append below the image.\n    ', 'parameters': {'type': 'object', 'properties': {'doc_filename': {'type': 'string', 'description': 'doc_filename'}, 'image_filename': {'type': 'string', 'description': 'image_filename'}, 'caption_text': {'type': 'string', 'description': 'caption_text'}}, 'required': ['doc_filename', 'image_filename', 'caption_text']}}}, 'prompt_template': None}
action: append_image_to_word_doc -> {'doc_filename': 'understanding_retrieval_in_agentic_systems_blog.docx', 'image_filename': 'images/image13.png', 'caption_text': 'RAG Process'}
action: append_image_to_word_doc(args={"doc_filename": "understanding_retrieval_in_agentic_systems_blog.docx", "image_filename": "images/image13.png", "caption_text": "RAG Process"}) -> Image added successfully.
action: append_code_to_word_doc -> {'name': 'append_code_to_word_doc', 'group': 'word_actions', 'pointer': <function append_code_to_word_doc at 0x00000257901BB6D0>, 'agent_action': {'type': 'function', 'function': {'name': 'append_code_to_word_doc', 'description': '\n    Append a code block to a Word document.\n\n    Parameters:\n    doc_filename (str): The path to the Word document.\n    code_text (str): The code text to append.\n    ', 'parameters': {'type': 'object', 'properties': {'doc_filename': {'type': 'string', 'description': 'doc_filename'}, 'code_text': {'type': 'string', 'description': 'code_text'}}, 'required': ['doc_filename', 'code_text']}}}, 'prompt_template': None}
action: append_code_to_word_doc -> {'doc_filename': 'understanding_retrieval_in_agentic_systems_blog.docx', 'code_text': 'import plotly.graph_objects as go\nfrom sklearn.feature_extraction.text import TfidfVectorizer\nfrom sklearn.metrics.pairwise import cosine_similarity\n\ndocuments = [\n    "The sky is blue and beautiful.",\n    "Love this blue and beautiful sky!",\n    "The quick brown fox jumps over the lazy dog.",\n    "A king\'s breakfast has sausages, ham, bacon, eggs, toast, and beans",\n    "I love green eggs, ham, sausages and bacon!",\n    "The brown fox is quick and the blue dog is lazy!",\n    "The sky is very blue and the sky is very beautiful today",\n    "The dog is lazy but the brown fox is quick!"\n]\n\nvectorizer = TfidfVectorizer()\nX = vectorizer.fit_transform(documents)'}
action: append_code_to_word_doc(args={"doc_filename": "understanding_retrieval_in_agentic_systems_blog.docx", "code_text": "import plotly.graph_objects as go\nfrom sklearn.feature_extraction.text import TfidfVectorizer\nfrom sklearn.metrics.pairwise import cosine_similarity\n\ndocuments = [\n    \"The sky is blue and beautiful.\",\n    \"Love this blue and beautiful sky!\",\n    \"The quick brown fox jumps over the lazy dog.\",\n    \"A king's breakfast has sausages, ham, bacon, eggs, toast, and beans\",\n    \"I love green eggs, ham, sausages and bacon!\",\n    \"The brown fox is quick and the blue dog is lazy!\",\n    \"The sky is very blue and the sky is very beautiful today\",\n    \"The dog is lazy but the brown fox is quick!\"\n]\n\nvectorizer = TfidfVectorizer()\nX = vectorizer.fit_transform(documents)"}) -> Code block added successfully.
action: append_heading_to_word_doc -> {'name': 'append_heading_to_word_doc', 'group': 'word_actions', 'pointer': <function append_heading_to_word_doc at 0x00000257901BA320>, 'agent_action': {'type': 'function', 'function': {'name': 'append_heading_to_word_doc', 'description': '\n    Append a heading to a Word document.\n\n    Parameters:\n    doc_filename (str): The path to the Word document.\n    heading_text (str): The text to append as a heading.\n    level (int): The heading level (0-9).\n    ', 'parameters': {'type': 'object', 'properties': {'doc_filename': {'type': 'string', 'description': 'doc_filename'}, 'heading_text': {'type': 'string', 'description': 'heading_text'}, 'level': {'type': 'string', 'description': 'level'}}, 'required': ['doc_filename', 'heading_text', 'level']}}}, 'prompt_template': None}
action: append_heading_to_word_doc -> {'doc_filename': 'understanding_retrieval_in_agentic_systems_blog.docx', 'heading_text': 'Delving into Semantic Search and Document Indexing', 'level': '1'}
action: append_heading_to_word_doc(args={"doc_filename": "understanding_retrieval_in_agentic_systems_blog.docx", "heading_text": "Delving into Semantic Search and Document Indexing", "level": "1"}) -> Heading added successfully.
action: append_paragraph_to_word_doc -> {'name': 'append_paragraph_to_word_doc', 'group': 'word_actions', 'pointer': <function append_paragraph_to_word_doc at 0x00000257901B9990>, 'agent_action': {'type': 'function', 'function': {'name': 'append_paragraph_to_word_doc', 'description': '\n    Append a paragraph to a Word document.\n\n    Parameters:\n    doc_filename (str): The path to the Word document.\n    paragraph_text (str): The text to append as a paragraph.\n    ', 'parameters': {'type': 'object', 'properties': {'doc_filename': {'type': 'string', 'description': 'doc_filename'}, 'paragraph_text': {'type': 'string', 'description': 'paragraph_text'}}, 'required': ['doc_filename', 'paragraph_text']}}}, 'prompt_template': None}
action: append_paragraph_to_word_doc -> {'doc_filename': 'understanding_retrieval_in_agentic_systems_blog.docx', 'paragraph_text': 'Document indexing is like creating a detailed map of a rugged terrain. It transforms information into a structured format, making it easier to retrieve. Semantic search, on the other hand, goes beyond the words to grasp the meaning, making your search more intuitive and accurate.'}
action: append_paragraph_to_word_doc(args={"doc_filename": "understanding_retrieval_in_agentic_systems_blog.docx", "paragraph_text": "Document indexing is like creating a detailed map of a rugged terrain. It transforms information into a structured format, making it easier to retrieve. Semantic search, on the other hand, goes beyond the words to grasp the meaning, making your search more intuitive and accurate."}) -> Paragraph added successfully.
action: append_image_to_word_doc -> {'name': 'append_image_to_word_doc', 'group': 'word_actions', 'pointer': <function append_image_to_word_doc at 0x00000257901BAD40>, 'agent_action': {'type': 'function', 'function': {'name': 'append_image_to_word_doc', 'description': '\n    Append an image with a caption to a Word document.\n\n    Parameters:\n    doc_filename (str): The path to the Word document.\n    image_filename (str): The path to the image file to append.\n    caption_text (str): The caption text to append below the image.\n    ', 'parameters': {'type': 'object', 'properties': {'doc_filename': {'type': 'string', 'description': 'doc_filename'}, 'image_filename': {'type': 'string', 'description': 'image_filename'}, 'caption_text': {'type': 'string', 'description': 'caption_text'}}, 'required': ['doc_filename', 'image_filename', 'caption_text']}}}, 'prompt_template': None}
action: append_image_to_word_doc -> {'doc_filename': 'understanding_retrieval_in_agentic_systems_blog.docx', 'image_filename': 'images/image4.png', 'caption_text': 'Cosine Similarity'}
action: append_image_to_word_doc(args={"doc_filename": "understanding_retrieval_in_agentic_systems_blog.docx", "image_filename": "images/image4.png", "caption_text": "Cosine Similarity"}) -> Image added successfully.
action: append_code_to_word_doc -> {'name': 'append_code_to_word_doc', 'group': 'word_actions', 'pointer': <function append_code_to_word_doc at 0x00000257901BB6D0>, 'agent_action': {'type': 'function', 'function': {'name': 'append_code_to_word_doc', 'description': '\n    Append a code block to a Word document.\n\n    Parameters:\n    doc_filename (str): The path to the Word document.\n    code_text (str): The code text to append.\n    ', 'parameters': {'type': 'object', 'properties': {'doc_filename': {'type': 'string', 'description': 'doc_filename'}, 'code_text': {'type': 'string', 'description': 'code_text'}}, 'required': ['doc_filename', 'code_text']}}}, 'prompt_template': None}
action: append_code_to_word_doc -> {'doc_filename': 'understanding_retrieval_in_agentic_systems_blog.docx', 'code_text': 'cosine_similarities = cosine_similarity(X)\n\nwhile True:\n    selected_document_index = input(f"Enter a document number (0-{len(documents)-1}) or \'exit\' to quit: ").strip()\n\n    if selected_document_index.lower() == \'exit\':\n        break\n\n    if not selected_document_index.isdigit() or not 0 <= int(selected_document_index) < len(documents):\n        print("Invalid input. Please enter a valid document number.")\n        continue\n\n    selected_document_index = int(selected_document_index)\n    selected_document_similarities = cosine_similarities[selected_document_index]'}
action: append_code_to_word_doc(args={"doc_filename": "understanding_retrieval_in_agentic_systems_blog.docx", "code_text": "cosine_similarities = cosine_similarity(X)\n\nwhile True:\n    selected_document_index = input(f\"Enter a document number (0-{len(documents)-1}) or 'exit' to quit: \").strip()\n\n    if selected_document_index.lower() == 'exit':\n        break\n\n    if not selected_document_index.isdigit() or not 0 <= int(selected_document_index) < len(documents):\n        print(\"Invalid input. Please enter a valid document number.\")\n        continue\n\n    selected_document_index = int(selected_document_index)\n    selected_document_similarities = cosine_similarities[selected_document_index]"}) -> Code block added successfully.
action: append_heading_to_word_doc -> {'name': 'append_heading_to_word_doc', 'group': 'word_actions', 'pointer': <function append_heading_to_word_doc at 0x00000257901BA320>, 'agent_action': {'type': 'function', 'function': {'name': 'append_heading_to_word_doc', 'description': '\n    Append a heading to a Word document.\n\n    Parameters:\n    doc_filename (str): The path to the Word document.\n    heading_text (str): The text to append as a heading.\n    level (int): The heading level (0-9).\n    ', 'parameters': {'type': 'object', 'properties': {'doc_filename': {'type': 'string', 'description': 'doc_filename'}, 'heading_text': {'type': 'string', 'description': 'heading_text'}, 'level': {'type': 'string', 'description': 'level'}}, 'required': ['doc_filename', 'heading_text', 'level']}}}, 'prompt_template': None}
action: append_heading_to_word_doc -> {'doc_filename': 'understanding_retrieval_in_agentic_systems_blog.docx', 'heading_text': 'Vector Databases and Similarity Search', 'level': '1'}
action: append_heading_to_word_doc(args={"doc_filename": "understanding_retrieval_in_agentic_systems_blog.docx", "heading_text": "Vector Databases and Similarity Search", "level": "1"}) -> Heading added successfully.
action: append_paragraph_to_word_doc -> {'name': 'append_paragraph_to_word_doc', 'group': 'word_actions', 'pointer': <function append_paragraph_to_word_doc at 0x00000257901B9990>, 'agent_action': {'type': 'function', 'function': {'name': 'append_paragraph_to_word_doc', 'description': '\n    Append a paragraph to a Word document.\n\n    Parameters:\n    doc_filename (str): The path to the Word document.\n    paragraph_text (str): The text to append as a paragraph.\n    ', 'parameters': {'type': 'object', 'properties': {'doc_filename': {'type': 'string', 'description': 'doc_filename'}, 'paragraph_text': {'type': 'string', 'description': 'paragraph_text'}}, 'required': ['doc_filename', 'paragraph_text']}}}, 'prompt_template': None}
action: append_paragraph_to_word_doc -> {'doc_filename': 'understanding_retrieval_in_agentic_systems_blog.docx', 'paragraph_text': 'Once vectorized, these document vectors are stored in a vector database. This storage allows fast similarity searches, enabling the AI to fetch relevant contexts swiftly. The ability to perform efficient similarity searches ensures the AI remains responsive and relevant.'}
action: append_paragraph_to_word_doc(args={"doc_filename": "understanding_retrieval_in_agentic_systems_blog.docx", "paragraph_text": "Once vectorized, these document vectors are stored in a vector database. This storage allows fast similarity searches, enabling the AI to fetch relevant contexts swiftly. The ability to perform efficient similarity searches ensures the AI remains responsive and relevant."}) -> Paragraph added successfully.
action: append_image_to_word_doc -> {'name': 'append_image_to_word_doc', 'group': 'word_actions', 'pointer': <function append_image_to_word_doc at 0x00000257901BAD40>, 'agent_action': {'type': 'function', 'function': {'name': 'append_image_to_word_doc', 'description': '\n    Append an image with a caption to a Word document.\n\n    Parameters:\n    doc_filename (str): The path to the Word document.\n    image_filename (str): The path to the image file to append.\n    caption_text (str): The caption text to append below the image.\n    ', 'parameters': {'type': 'object', 'properties': {'doc_filename': {'type': 'string', 'description': 'doc_filename'}, 'image_filename': {'type': 'string', 'description': 'image_filename'}, 'caption_text': {'type': 'string', 'description': 'caption_text'}}, 'required': ['doc_filename', 'image_filename', 'caption_text']}}}, 'prompt_template': None}
action: append_image_to_word_doc -> {'doc_filename': 'understanding_retrieval_in_agentic_systems_blog.docx', 'image_filename': 'images/image5.png', 'caption_text': 'Vector Similarity'}
action: append_image_to_word_doc(args={"doc_filename": "understanding_retrieval_in_agentic_systems_blog.docx", "image_filename": "images/image5.png", "caption_text": "Vector Similarity"}) -> Image added successfully.
action: append_heading_to_word_doc -> {'name': 'append_heading_to_word_doc', 'group': 'word_actions', 'pointer': <function append_heading_to_word_doc at 0x00000257901BA320>, 'agent_action': {'type': 'function', 'function': {'name': 'append_heading_to_word_doc', 'description': '\n    Append a heading to a Word document.\n\n    Parameters:\n    doc_filename (str): The path to the Word document.\n    heading_text (str): The text to append as a heading.\n    level (int): The heading level (0-9).\n    ', 'parameters': {'type': 'object', 'properties': {'doc_filename': {'type': 'string', 'description': 'doc_filename'}, 'heading_text': {'type': 'string', 'description': 'heading_text'}, 'level': {'type': 'string', 'description': 'level'}}, 'required': ['doc_filename', 'heading_text', 'level']}}}, 'prompt_template': None}
action: append_heading_to_word_doc -> {'doc_filename': 'understanding_retrieval_in_agentic_systems_blog.docx', 'heading_text': 'Constructing RAG with LangChain', 'level': '1'}
action: append_heading_to_word_doc(args={"doc_filename": "understanding_retrieval_in_agentic_systems_blog.docx", "heading_text": "Constructing RAG with LangChain", "level": "1"}) -> Heading added successfully.
action: append_paragraph_to_word_doc -> {'name': 'append_paragraph_to_word_doc', 'group': 'word_actions', 'pointer': <function append_paragraph_to_word_doc at 0x00000257901B9990>, 'agent_action': {'type': 'function', 'function': {'name': 'append_paragraph_to_word_doc', 'description': '\n    Append a paragraph to a Word document.\n\n    Parameters:\n    doc_filename (str): The path to the Word document.\n    paragraph_text (str): The text to append as a paragraph.\n    ', 'parameters': {'type': 'object', 'properties': {'doc_filename': {'type': 'string', 'description': 'doc_filename'}, 'paragraph_text': {'type': 'string', 'description': 'paragraph_text'}}, 'required': ['doc_filename', 'paragraph_text']}}}, 'prompt_template': None}
action: append_paragraph_to_word_doc -> {'doc_filename': 'understanding_retrieval_in_agentic_systems_blog.docx', 'paragraph_text': "LangChain offers powerful tools to implement RAG workflows. It abstracts retrieval processes, making them accessible and efficient. By using LangChain, we can build robust, scalable retrieval systems that enhance the AI's knowledge and memory capabilities."}
action: append_paragraph_to_word_doc(args={"doc_filename": "understanding_retrieval_in_agentic_systems_blog.docx", "paragraph_text": "LangChain offers powerful tools to implement RAG workflows. It abstracts retrieval processes, making them accessible and efficient. By using LangChain, we can build robust, scalable retrieval systems that enhance the AI's knowledge and memory capabilities."}) -> Paragraph added successfully.
action: append_image_to_word_doc -> {'name': 'append_image_to_word_doc', 'group': 'word_actions', 'pointer': <function append_image_to_word_doc at 0x00000257901BAD40>, 'agent_action': {'type': 'function', 'function': {'name': 'append_image_to_word_doc', 'description': '\n    Append an image with a caption to a Word document.\n\n    Parameters:\n    doc_filename (str): The path to the Word document.\n    image_filename (str): The path to the image file to append.\n    caption_text (str): The caption text to append below the image.\n    ', 'parameters': {'type': 'object', 'properties': {'doc_filename': {'type': 'string', 'description': 'doc_filename'}, 'image_filename': {'type': 'string', 'description': 'image_filename'}, 'caption_text': {'type': 'string', 'description': 'caption_text'}}, 'required': ['doc_filename', 'image_filename', 'caption_text']}}}, 'prompt_template': None}
action: append_image_to_word_doc -> {'doc_filename': 'understanding_retrieval_in_agentic_systems_blog.docx', 'image_filename': 'images/image7.png', 'caption_text': 'LangChain Process'}
action: append_image_to_word_doc(args={"doc_filename": "understanding_retrieval_in_agentic_systems_blog.docx", "image_filename": "images/image7.png", "caption_text": "LangChain Process"}) -> Image added successfully.
action: append_code_to_word_doc -> {'name': 'append_code_to_word_doc', 'group': 'word_actions', 'pointer': <function append_code_to_word_doc at 0x00000257901BB6D0>, 'agent_action': {'type': 'function', 'function': {'name': 'append_code_to_word_doc', 'description': '\n    Append a code block to a Word document.\n\n    Parameters:\n    doc_filename (str): The path to the Word document.\n    code_text (str): The code text to append.\n    ', 'parameters': {'type': 'object', 'properties': {'doc_filename': {'type': 'string', 'description': 'doc_filename'}, 'code_text': {'type': 'string', 'description': 'code_text'}}, 'required': ['doc_filename', 'code_text']}}}, 'prompt_template': None}
action: append_code_to_word_doc -> {'doc_filename': 'understanding_retrieval_in_agentic_systems_blog.docx', 'code_text': 'from langchain.document_loaders import UnstructuredHTMLLoader\nfrom langchain.text_splitter import RecursiveCharacterTextSplitter\n\nloader = UnstructuredHTMLLoader("sample_documents/mother_goose.html")\ndata = loader.load()\n\ntext_splitter = RecursiveCharacterTextSplitter(\n    chunk_size=100,\n    chunk_overlap=25,\n    length_function=len,\n    add_start_index=True,\n)\ndocuments = text_splitter.split_documents(data)'}
action: append_code_to_word_doc(args={"doc_filename": "understanding_retrieval_in_agentic_systems_blog.docx", "code_text": "from langchain.document_loaders import UnstructuredHTMLLoader\nfrom langchain.text_splitter import RecursiveCharacterTextSplitter\n\nloader = UnstructuredHTMLLoader(\"sample_documents/mother_goose.html\")\ndata = loader.load()\n\ntext_splitter = RecursiveCharacterTextSplitter(\n    chunk_size=100,\n    chunk_overlap=25,\n    length_function=len,\n    add_start_index=True,\n)\ndocuments = text_splitter.split_documents(data)"}) -> Code block added successfully.
action: append_heading_to_word_doc -> {'name': 'append_heading_to_word_doc', 'group': 'word_actions', 'pointer': <function append_heading_to_word_doc at 0x00000257901BA320>, 'agent_action': {'type': 'function', 'function': {'name': 'append_heading_to_word_doc', 'description': '\n    Append a heading to a Word document.\n\n    Parameters:\n    doc_filename (str): The path to the Word document.\n    heading_text (str): The text to append as a heading.\n    level (int): The heading level (0-9).\n    ', 'parameters': {'type': 'object', 'properties': {'doc_filename': {'type': 'string', 'description': 'doc_filename'}, 'heading_text': {'type': 'string', 'description': 'heading_text'}, 'level': {'type': 'string', 'description': 'level'}}, 'required': ['doc_filename', 'heading_text', 'level']}}}, 'prompt_template': None}
action: append_heading_to_word_doc -> {'doc_filename': 'understanding_retrieval_in_agentic_systems_blog.docx', 'heading_text': 'Implementing Memory in Agentic Systems', 'level': '1'}
action: append_heading_to_word_doc(args={"doc_filename": "understanding_retrieval_in_agentic_systems_blog.docx", "heading_text": "Implementing Memory in Agentic Systems", "level": "1"}) -> Heading added successfully.
action: append_paragraph_to_word_doc -> {'name': 'append_paragraph_to_word_doc', 'group': 'word_actions', 'pointer': <function append_paragraph_to_word_doc at 0x00000257901B9990>, 'agent_action': {'type': 'function', 'function': {'name': 'append_paragraph_to_word_doc', 'description': '\n    Append a paragraph to a Word document.\n\n    Parameters:\n    doc_filename (str): The path to the Word document.\n    paragraph_text (str): The text to append as a paragraph.\n    ', 'parameters': {'type': 'object', 'properties': {'doc_filename': {'type': 'string', 'description': 'doc_filename'}, 'paragraph_text': {'type': 'string', 'description': 'paragraph_text'}}, 'required': ['doc_filename', 'paragraph_text']}}}, 'prompt_template': None}
action: append_paragraph_to_word_doc -> {'doc_filename': 'understanding_retrieval_in_agentic_systems_blog.docx', 'paragraph_text': 'Agentic memory incorporates various forms—sensory, short-term, and long-term—to enrich interactions. Each type of memory enhances the AI’s capability to contextualize responses based on past interactions, making conversations more natural and meaningful.'}
action: append_paragraph_to_word_doc(args={"doc_filename": "understanding_retrieval_in_agentic_systems_blog.docx", "paragraph_text": "Agentic memory incorporates various forms—sensory, short-term, and long-term—to enrich interactions. Each type of memory enhances the AI’s capability to contextualize responses based on past interactions, making conversations more natural and meaningful."}) -> Paragraph added successfully.
action: append_image_to_word_doc -> {'name': 'append_image_to_word_doc', 'group': 'word_actions', 'pointer': <function append_image_to_word_doc at 0x00000257901BAD40>, 'agent_action': {'type': 'function', 'function': {'name': 'append_image_to_word_doc', 'description': '\n    Append an image with a caption to a Word document.\n\n    Parameters:\n    doc_filename (str): The path to the Word document.\n    image_filename (str): The path to the image file to append.\n    caption_text (str): The caption text to append below the image.\n    ', 'parameters': {'type': 'object', 'properties': {'doc_filename': {'type': 'string', 'description': 'doc_filename'}, 'image_filename': {'type': 'string', 'description': 'image_filename'}, 'caption_text': {'type': 'string', 'description': 'caption_text'}}, 'required': ['doc_filename', 'image_filename', 'caption_text']}}}, 'prompt_template': None}
action: append_image_to_word_doc -> {'doc_filename': 'understanding_retrieval_in_agentic_systems_blog.docx', 'image_filename': 'images/image21.png', 'caption_text': 'Memory Workflow'}
action: append_image_to_word_doc(args={"doc_filename": "understanding_retrieval_in_agentic_systems_blog.docx", "image_filename": "images/image21.png", "caption_text": "Memory Workflow"}) -> Image added successfully.
action: append_heading_to_word_doc -> {'name': 'append_heading_to_word_doc', 'group': 'word_actions', 'pointer': <function append_heading_to_word_doc at 0x00000257901BA320>, 'agent_action': {'type': 'function', 'function': {'name': 'append_heading_to_word_doc', 'description': '\n    Append a heading to a Word document.\n\n    Parameters:\n    doc_filename (str): The path to the Word document.\n    heading_text (str): The text to append as a heading.\n    level (int): The heading level (0-9).\n    ', 'parameters': {'type': 'object', 'properties': {'doc_filename': {'type': 'string', 'description': 'doc_filename'}, 'heading_text': {'type': 'string', 'description': 'heading_text'}, 'level': {'type': 'string', 'description': 'level'}}, 'required': ['doc_filename', 'heading_text', 'level']}}}, 'prompt_template': None}
action: append_heading_to_word_doc -> {'doc_filename': 'understanding_retrieval_in_agentic_systems_blog.docx', 'heading_text': 'Conclusion', 'level': '1'}
action: append_heading_to_word_doc(args={"doc_filename":"understanding_retrieval_in_agentic_systems_blog.docx","heading_text":"Conclusion","level":"1"}) -> Heading added successfully.
action: append_paragraph_to_word_doc -> {'name': 'append_paragraph_to_word_doc', 'group': 'word_actions', 'pointer': <function append_paragraph_to_word_doc at 0x00000257901B9990>, 'agent_action': {'type': 'function', 'function': {'name': 'append_paragraph_to_word_doc', 'description': '\n    Append a paragraph to a Word document.\n\n    Parameters:\n    doc_filename (str): The path to the Word document.\n    paragraph_text (str): The text to append as a paragraph.\n    ', 'parameters': {'type': 'object', 'properties': {'doc_filename': {'type': 'string', 'description': 'doc_filename'}, 'paragraph_text': {'type': 'string', 'description': 'paragraph_text'}}, 'required': ['doc_filename', 'paragraph_text']}}}, 'prompt_template': None}
action: append_paragraph_to_word_doc -> {'doc_filename': 'understanding_retrieval_in_agentic_systems_blog.docx', 'paragraph_text': "The journey through retrieval in agentic systems reveals a rich landscape where memory and knowledge intertwine. From semantic search to advanced memory implementations, each step enhances the capability and depth of AI interactions. As we continue to explore these terrains, the potential for more intelligent and intuitive systems burgeons, promising a future where AI doesn't just respond but understands."}
action: append_paragraph_to_word_doc(args={"doc_filename":"understanding_retrieval_in_agentic_systems_blog.docx","paragraph_text":"The journey through retrieval in agentic systems reveals a rich landscape where memory and knowledge intertwine. From semantic search to advanced memory implementations, each step enhances the capability and depth of AI interactions. As we continue to explore these terrains, the potential for more intelligent and intuitive systems burgeons, promising a future where AI doesn't just respond but understands."}) -> Paragraph added successfully.
assistant > action: create_word_doc -> {'name': 'create_word_doc', 'group': 'word_actions', 'pointer': <function create_word_doc at 0x00000257901B9000>, 'agent_action': {'type': 'function', 'function': {'name': 'create_word_doc', 'description': '\n    Create a new Word document.\n\n    Parameters:\n    doc_filename (str): The path to the Word document.\n    ', 'parameters': {'type': 'object', 'properties': {'doc_filename': {'type': 'string', 'description': 'doc_filename'}}, 'required': ['doc_filename']}}}, 'prompt_template': None}
action: create_word_doc -> {'doc_filename': 'understanding_retrieval_in_agentic_systems_blog.docx'}
action: create_word_doc(args={"doc_filename":"understanding_retrieval_in_agentic_systems_blog.docx"}) -> Document created successfully.
action: append_paragraph_to_word_doc -> {'name': 'append_paragraph_to_word_doc', 'group': 'word_actions', 'pointer': <function append_paragraph_to_word_doc at 0x00000257901B9990>, 'agent_action': {'type': 'function', 'function': {'name': 'append_paragraph_to_word_doc', 'description': '\n    Append a paragraph to a Word document.\n\n    Parameters:\n    doc_filename (str): The path to the Word document.\n    paragraph_text (str): The text to append as a paragraph.\n    ', 'parameters': {'type': 'object', 'properties': {'doc_filename': {'type': 'string', 'description': 'doc_filename'}, 'paragraph_text': {'type': 'string', 'description': 'paragraph_text'}}, 'required': ['doc_filename', 'paragraph_text']}}}, 'prompt_template': None}
action: append_paragraph_to_word_doc -> {'doc_filename': 'understanding_retrieval_in_agentic_systems_blog.docx', 'paragraph_text': 'The field of Artificial Intelligence is growing by leaps and bounds, like a young sapling straining towards the sun. One of its most exciting branches is the development of agentic systems—agents infused with memory and knowledge that can interact more naturally and effectively with us. Let’s delve into how retrieval plays a key role in making these systems tick.'}
action: append_paragraph_to_word_doc(args={"doc_filename": "understanding_retrieval_in_agentic_systems_blog.docx", "paragraph_text": "The field of Artificial Intelligence is growing by leaps and bounds, like a young sapling straining towards the sun. One of its most exciting branches is the development of agentic systems—agents infused with memory and knowledge that can interact more naturally and effectively with us. Let’s delve into how retrieval plays a key role in making these systems tick."}) -> Paragraph added successfully.
action: append_image_to_word_doc -> {'name': 'append_image_to_word_doc', 'group': 'word_actions', 'pointer': <function append_image_to_word_doc at 0x00000257901BAD40>, 'agent_action': {'type': 'function', 'function': {'name': 'append_image_to_word_doc', 'description': '\n    Append an image with a caption to a Word document.\n\n    Parameters:\n    doc_filename (str): The path to the Word document.\n    image_filename (str): The path to the image file to append.\n    caption_text (str): The caption text to append below the image.\n    ', 'parameters': {'type': 'object', 'properties': {'doc_filename': {'type': 'string', 'description': 'doc_filename'}, 'image_filename': {'type': 'string', 'description': 'image_filename'}, 'caption_text': {'type': 'string', 'description': 'caption_text'}}, 'required': ['doc_filename', 'image_filename', 'caption_text']}}}, 'prompt_template': None}
action: append_image_to_word_doc -> {'doc_filename': 'understanding_retrieval_in_agentic_systems_blog.docx', 'image_filename': 'images/image1.png', 'caption_text': 'Understanding Retrieval'}
action: append_image_to_word_doc(args={"doc_filename": "understanding_retrieval_in_agentic_systems_blog.docx", "image_filename": "images/image1.png", "caption_text": "Understanding Retrieval"}) -> Image added successfully.
action: append_heading_to_word_doc -> {'name': 'append_heading_to_word_doc', 'group': 'word_actions', 'pointer': <function append_heading_to_word_doc at 0x00000257901BA320>, 'agent_action': {'type': 'function', 'function': {'name': 'append_heading_to_word_doc', 'description': '\n    Append a heading to a Word document.\n\n    Parameters:\n    doc_filename (str): The path to the Word document.\n    heading_text (str): The text to append as a heading.\n    level (int): The heading level (0-9).\n    ', 'parameters': {'type': 'object', 'properties': {'doc_filename': {'type': 'string', 'description': 'doc_filename'}, 'heading_text': {'type': 'string', 'description': 'heading_text'}, 'level': {'type': 'string', 'description': 'level'}}, 'required': ['doc_filename', 'heading_text', 'level']}}}, 'prompt_template': None}
action: append_heading_to_word_doc -> {'doc_filename': 'understanding_retrieval_in_agentic_systems_blog.docx', 'heading_text': 'Introduction', 'level': '1'}
action: append_heading_to_word_doc(args={"doc_filename": "understanding_retrieval_in_agentic_systems_blog.docx", "heading_text": "Introduction", "level": "1"}) -> Heading added successfully.
action: append_paragraph_to_word_doc -> {'name': 'append_paragraph_to_word_doc', 'group': 'word_actions', 'pointer': <function append_paragraph_to_word_doc at 0x00000257901B9990>, 'agent_action': {'type': 'function', 'function': {'name': 'append_paragraph_to_word_doc', 'description': '\n    Append a paragraph to a Word document.\n\n    Parameters:\n    doc_filename (str): The path to the Word document.\n    paragraph_text (str): The text to append as a paragraph.\n    ', 'parameters': {'type': 'object', 'properties': {'doc_filename': {'type': 'string', 'description': 'doc_filename'}, 'paragraph_text': {'type': 'string', 'description': 'paragraph_text'}}, 'required': ['doc_filename', 'paragraph_text']}}}, 'prompt_template': None}
action: append_paragraph_to_word_doc -> {'doc_filename': 'understanding_retrieval_in_agentic_systems_blog.docx', 'paragraph_text': "In our ever-evolving world of AI, the ability to retrieve information is foundational. Whether it's about drawing from vast databases or pulling snippets of past interactions, retrieval shapes the context and enhances the capability of AI systems. This journey will cover retrieval across semantic search, document indexing, and the intricacies of retrieval-augmented generation (RAG) workflows."}
action: append_paragraph_to_word_doc(args={"doc_filename": "understanding_retrieval_in_agentic_systems_blog.docx", "paragraph_text": "In our ever-evolving world of AI, the ability to retrieve information is foundational. Whether it's about drawing from vast databases or pulling snippets of past interactions, retrieval shapes the context and enhances the capability of AI systems. This journey will cover retrieval across semantic search, document indexing, and the intricacies of retrieval-augmented generation (RAG) workflows."}) -> Paragraph added successfully.
action: append_paragraph_to_word_doc -> {'name': 'append_paragraph_to_word_doc', 'group': 'word_actions', 'pointer': <function append_paragraph_to_word_doc at 0x00000257901B9990>, 'agent_action': {'type': 'function', 'function': {'name': 'append_paragraph_to_word_doc', 'description': '\n    Append a paragraph to a Word document.\n\n    Parameters:\n    doc_filename (str): The path to the Word document.\n    paragraph_text (str): The text to append as a paragraph.\n    ', 'parameters': {'type': 'object', 'properties': {'doc_filename': {'type': 'string', 'description': 'doc_filename'}, 'paragraph_text': {'type': 'string', 'description': 'paragraph_text'}}, 'required': ['doc_filename', 'paragraph_text']}}}, 'prompt_template': None}
action: append_paragraph_to_word_doc -> {'doc_filename': 'understanding_retrieval_in_agentic_systems_blog.docx', 'paragraph_text': "Retrieval is more than just fetching data; it's about understanding and contextualizing information. The synergy between memory and retrieval mechanisms enables AI to simulate human-like patterns of understanding and response. By delving deep into how retrieval works, we can better appreciate the artificial minds we are constructing."}
action: append_paragraph_to_word_doc(args={"doc_filename": "understanding_retrieval_in_agentic_systems_blog.docx", "paragraph_text": "Retrieval is more than just fetching data; it's about understanding and contextualizing information. The synergy between memory and retrieval mechanisms enables AI to simulate human-like patterns of understanding and response. By delving deep into how retrieval works, we can better appreciate the artificial minds we are constructing."}) -> Paragraph added successfully.
action: append_paragraph_to_word_doc -> {'name': 'append_paragraph_to_word_doc', 'group': 'word_actions', 'pointer': <function append_paragraph_to_word_doc at 0x00000257901B9990>, 'agent_action': {'type': 'function', 'function': {'name': 'append_paragraph_to_word_doc', 'description': '\n    Append a paragraph to a Word document.\n\n    Parameters:\n    doc_filename (str): The path to the Word document.\n    paragraph_text (str): The text to append as a paragraph.\n    ', 'parameters': {'type': 'object', 'properties': {'doc_filename': {'type': 'string', 'description': 'doc_filename'}, 'paragraph_text': {'type': 'string', 'description': 'paragraph_text'}}, 'required': ['doc_filename', 'paragraph_text']}}}, 'prompt_template': None}
action: append_paragraph_to_word_doc -> {'doc_filename': 'understanding_retrieval_in_agentic_systems_blog.docx', 'paragraph_text': "In this blog, we'll explore the critical aspects of retrieval in AI applications. From document indexing to vector databases, every step in the process plays a crucial role in making these systems smarter and more efficient. With examples and code snippets, we'll walk through the practical applications of these concepts, giving you a comprehensive understanding of its significance."}
action: append_paragraph_to_word_doc(args={"doc_filename": "understanding_retrieval_in_agentic_systems_blog.docx", "paragraph_text": "In this blog, we'll explore the critical aspects of retrieval in AI applications. From document indexing to vector databases, every step in the process plays a crucial role in making these systems smarter and more efficient. With examples and code snippets, we'll walk through the practical applications of these concepts, giving you a comprehensive understanding of its significance."}) -> Paragraph added successfully.
action: append_image_to_word_doc -> {'name': 'append_image_to_word_doc', 'group': 'word_actions', 'pointer': <function append_image_to_word_doc at 0x00000257901BAD40>, 'agent_action': {'type': 'function', 'function': {'name': 'append_image_to_word_doc', 'description': '\n    Append an image with a caption to a Word document.\n\n    Parameters:\n    doc_filename (str): The path to the Word document.\n    image_filename (str): The path to the image file to append.\n    caption_text (str): The caption text to append below the image.\n    ', 'parameters': {'type': 'object', 'properties': {'doc_filename': {'type': 'string', 'description': 'doc_filename'}, 'image_filename': {'type': 'string', 'description': 'image_filename'}, 'caption_text': {'type': 'string', 'description': 'caption_text'}}, 'required': ['doc_filename', 'image_filename', 'caption_text']}}}, 'prompt_template': None}
action: append_image_to_word_doc -> {'doc_filename': 'understanding_retrieval_in_agentic_systems_blog.docx', 'image_filename': 'images/image3.png', 'caption_text': 'Memory and retrieval in AI'}
action: append_image_to_word_doc(args={"doc_filename": "understanding_retrieval_in_agentic_systems_blog.docx", "image_filename": "images/image3.png", "caption_text": "Memory and retrieval in AI"}) -> Image added successfully.
action: append_heading_to_word_doc -> {'name': 'append_heading_to_word_doc', 'group': 'word_actions', 'pointer': <function append_heading_to_word_doc at 0x00000257901BA320>, 'agent_action': {'type': 'function', 'function': {'name': 'append_heading_to_word_doc', 'description': '\n    Append a heading to a Word document.\n\n    Parameters:\n    doc_filename (str): The path to the Word document.\n    heading_text (str): The text to append as a heading.\n    level (int): The heading level (0-9).\n    ', 'parameters': {'type': 'object', 'properties': {'doc_filename': {'type': 'string', 'description': 'doc_filename'}, 'heading_text': {'type': 'string', 'description': 'heading_text'}, 'level': {'type': 'string', 'description': 'level'}}, 'required': ['doc_filename', 'heading_text', 'level']}}}, 'prompt_template': None}
action: append_heading_to_word_doc -> {'doc_filename': 'understanding_retrieval_in_agentic_systems_blog.docx', 'heading_text': 'Basics of Retrieval Augmented Generation (RAG)', 'level': '1'}
action: append_heading_to_word_doc(args={"doc_filename": "understanding_retrieval_in_agentic_systems_blog.docx", "heading_text": "Basics of Retrieval Augmented Generation (RAG)", "level": "1"}) -> Heading added successfully.
action: append_paragraph_to_word_doc -> {'name': 'append_paragraph_to_word_doc', 'group': 'word_actions', 'pointer': <function append_paragraph_to_word_doc at 0x00000257901B9990>, 'agent_action': {'type': 'function', 'function': {'name': 'append_paragraph_to_word_doc', 'description': '\n    Append a paragraph to a Word document.\n\n    Parameters:\n    doc_filename (str): The path to the Word document.\n    paragraph_text (str): The text to append as a paragraph.\n    ', 'parameters': {'type': 'object', 'properties': {'doc_filename': {'type': 'string', 'description': 'doc_filename'}, 'paragraph_text': {'type': 'string', 'description': 'paragraph_text'}}, 'required': ['doc_filename', 'paragraph_text']}}}, 'prompt_template': None}
action: append_paragraph_to_word_doc -> {'doc_filename': 'understanding_retrieval_in_agentic_systems_blog.docx', 'paragraph_text': 'When you ask a question to a sophisticated AI system, the RAG mechanism swings into action. It takes your query and dives into preloaded documents, transforms them into context chunks, embeds these chunks into vectors, and stores them in a vector database. When you query again, it compares the query with these stored vectors and pulls the most relevant chunks to form an answer.'}
action: append_paragraph_to_word_doc(args={"doc_filename": "understanding_retrieval_in_agentic_systems_blog.docx", "paragraph_text": "When you ask a question to a sophisticated AI system, the RAG mechanism swings into action. It takes your query and dives into preloaded documents, transforms them into context chunks, embeds these chunks into vectors, and stores them in a vector database. When you query again, it compares the query with these stored vectors and pulls the most relevant chunks to form an answer."}) -> Paragraph added successfully.
action: append_paragraph_to_word_doc -> {'name': 'append_paragraph_to_word_doc', 'group': 'word_actions', 'pointer': <function append_paragraph_to_word_doc at 0x00000257901B9990>, 'agent_action': {'type': 'function', 'function': {'name': 'append_paragraph_to_word_doc', 'description': '\n    Append a paragraph to a Word document.\n\n    Parameters:\n    doc_filename (str): The path to the Word document.\n    paragraph_text (str): The text to append as a paragraph.\n    ', 'parameters': {'type': 'object', 'properties': {'doc_filename': {'type': 'string', 'description': 'doc_filename'}, 'paragraph_text': {'type': 'string', 'description': 'paragraph_text'}}, 'required': ['doc_filename', 'paragraph_text']}}}, 'prompt_template': None}
action: append_paragraph_to_word_doc -> {'doc_filename': 'understanding_retrieval_in_agentic_systems_blog.docx', 'paragraph_text': 'RAG, or Retrieval Augmented Generation, combines the strengths of retrieval systems with generation models. The key here is context. By providing more relevant and detailed context to the language model, it can generate more accurate and meaningful responses. This process involves several steps, starting with document loading and ending with querying an embedded vector database.'}
action: append_paragraph_to_word_doc(args={"doc_filename": "understanding_retrieval_in_agentic_systems_blog.docx", "paragraph_text": "RAG, or Retrieval Augmented Generation, combines the strengths of retrieval systems with generation models. The key here is context. By providing more relevant and detailed context to the language model, it can generate more accurate and meaningful responses. This process involves several steps, starting with document loading and ending with querying an embedded vector database."}) -> Paragraph added successfully.
action: append_paragraph_to_word_doc -> {'name': 'append_paragraph_to_word_doc', 'group': 'word_actions', 'pointer': <function append_paragraph_to_word_doc at 0x00000257901B9990>, 'agent_action': {'type': 'function', 'function': {'name': 'append_paragraph_to_word_doc', 'description': '\n    Append a paragraph to a Word document.\n\n    Parameters:\n    doc_filename (str): The path to the Word document.\n    paragraph_text (str): The text to append as a paragraph.\n    ', 'parameters': {'type': 'object', 'properties': {'doc_filename': {'type': 'string', 'description': 'doc_filename'}, 'paragraph_text': {'type': 'string', 'description': 'paragraph_text'}}, 'required': ['doc_filename', 'paragraph_text']}}}, 'prompt_template': None}
action: append_paragraph_to_word_doc -> {'doc_filename': 'understanding_retrieval_in_agentic_systems_blog.docx', 'paragraph_text': 'The effectiveness of RAG lies in its ability to handle vast amounts of unstructured data and provide coherent and contextually accurate answers. This makes it particularly useful for applications such as document chat systems and question-and-answer systems where precise and relevant responses are critical.'}
action: append_paragraph_to_word_doc(args={"doc_filename": "understanding_retrieval_in_agentic_systems_blog.docx", "paragraph_text": "The effectiveness of RAG lies in its ability to handle vast amounts of unstructured data and provide coherent and contextually accurate answers. This makes it particularly useful for applications such as document chat systems and question-and-answer systems where precise and relevant responses are critical."}) -> Paragraph added successfully.
action: append_image_to_word_doc -> {'name': 'append_image_to_word_doc', 'group': 'word_actions', 'pointer': <function append_image_to_word_doc at 0x00000257901BAD40>, 'agent_action': {'type': 'function', 'function': {'name': 'append_image_to_word_doc', 'description': '\n    Append an image with a caption to a Word document.\n\n    Parameters:\n    doc_filename (str): The path to the Word document.\n    image_filename (str): The path to the image file to append.\n    caption_text (str): The caption text to append below the image.\n    ', 'parameters': {'type': 'object', 'properties': {'doc_filename': {'type': 'string', 'description': 'doc_filename'}, 'image_filename': {'type': 'string', 'description': 'image_filename'}, 'caption_text': {'type': 'string', 'description': 'caption_text'}}, 'required': ['doc_filename', 'image_filename', 'caption_text']}}}, 'prompt_template': None}
action: append_image_to_word_doc -> {'doc_filename': 'understanding_retrieval_in_agentic_systems_blog.docx', 'image_filename': 'images/image13.png', 'caption_text': 'RAG Process'}
action: append_image_to_word_doc(args={"doc_filename": "understanding_retrieval_in_agentic_systems_blog.docx", "image_filename": "images/image13.png", "caption_text": "RAG Process"}) -> Image added successfully.
action: append_code_to_word_doc -> {'name': 'append_code_to_word_doc', 'group': 'word_actions', 'pointer': <function append_code_to_word_doc at 0x00000257901BB6D0>, 'agent_action': {'type': 'function', 'function': {'name': 'append_code_to_word_doc', 'description': '\n    Append a code block to a Word document.\n\n    Parameters:\n    doc_filename (str): The path to the Word document.\n    code_text (str): The code text to append.\n    ', 'parameters': {'type': 'object', 'properties': {'doc_filename': {'type': 'string', 'description': 'doc_filename'}, 'code_text': {'type': 'string', 'description': 'code_text'}}, 'required': ['doc_filename', 'code_text']}}}, 'prompt_template': None}
action: append_code_to_word_doc -> {'doc_filename': 'understanding_retrieval_in_agentic_systems_blog.docx', 'code_text': 'import plotly.graph_objects as go\nfrom sklearn.feature_extraction.text import TfidfVectorizer\nfrom sklearn.metrics.pairwise import cosine_similarity\n\ndocuments = [\n    "The sky is blue and beautiful.",\n    "Love this blue and beautiful sky!",\n    "The quick brown fox jumps over the lazy dog.",\n    "A king\'s breakfast has sausages, ham, bacon, eggs, toast, and beans",\n    "I love green eggs, ham, sausages and bacon!",\n    "The brown fox is quick and the blue dog is lazy!",\n    "The sky is very blue and the sky is very beautiful today",\n    "The dog is lazy but the brown fox is quick!"\n]\n\nvectorizer = TfidfVectorizer()\nX = vectorizer.fit_transform(documents)'}
action: append_code_to_word_doc(args={"doc_filename": "understanding_retrieval_in_agentic_systems_blog.docx", "code_text": "import plotly.graph_objects as go\nfrom sklearn.feature_extraction.text import TfidfVectorizer\nfrom sklearn.metrics.pairwise import cosine_similarity\n\ndocuments = [\n    \"The sky is blue and beautiful.\",\n    \"Love this blue and beautiful sky!\",\n    \"The quick brown fox jumps over the lazy dog.\",\n    \"A king's breakfast has sausages, ham, bacon, eggs, toast, and beans\",\n    \"I love green eggs, ham, sausages and bacon!\",\n    \"The brown fox is quick and the blue dog is lazy!\",\n    \"The sky is very blue and the sky is very beautiful today\",\n    \"The dog is lazy but the brown fox is quick!\"\n]\n\nvectorizer = TfidfVectorizer()\nX = vectorizer.fit_transform(documents)"}) -> Code block added successfully.
action: append_heading_to_word_doc -> {'name': 'append_heading_to_word_doc', 'group': 'word_actions', 'pointer': <function append_heading_to_word_doc at 0x00000257901BA320>, 'agent_action': {'type': 'function', 'function': {'name': 'append_heading_to_word_doc', 'description': '\n    Append a heading to a Word document.\n\n    Parameters:\n    doc_filename (str): The path to the Word document.\n    heading_text (str): The text to append as a heading.\n    level (int): The heading level (0-9).\n    ', 'parameters': {'type': 'object', 'properties': {'doc_filename': {'type': 'string', 'description': 'doc_filename'}, 'heading_text': {'type': 'string', 'description': 'heading_text'}, 'level': {'type': 'string', 'description': 'level'}}, 'required': ['doc_filename', 'heading_text', 'level']}}}, 'prompt_template': None}
action: append_heading_to_word_doc -> {'doc_filename': 'understanding_retrieval_in_agentic_systems_blog.docx', 'heading_text': 'Delving into Semantic Search and Document Indexing', 'level': '1'}
action: append_heading_to_word_doc(args={"doc_filename": "understanding_retrieval_in_agentic_systems_blog.docx", "heading_text": "Delving into Semantic Search and Document Indexing", "level": "1"}) -> Heading added successfully.
action: append_paragraph_to_word_doc -> {'name': 'append_paragraph_to_word_doc', 'group': 'word_actions', 'pointer': <function append_paragraph_to_word_doc at 0x00000257901B9990>, 'agent_action': {'type': 'function', 'function': {'name': 'append_paragraph_to_word_doc', 'description': '\n    Append a paragraph to a Word document.\n\n    Parameters:\n    doc_filename (str): The path to the Word document.\n    paragraph_text (str): The text to append as a paragraph.\n    ', 'parameters': {'type': 'object', 'properties': {'doc_filename': {'type': 'string', 'description': 'doc_filename'}, 'paragraph_text': {'type': 'string', 'description': 'paragraph_text'}}, 'required': ['doc_filename', 'paragraph_text']}}}, 'prompt_template': None}
action: append_paragraph_to_word_doc -> {'doc_filename': 'understanding_retrieval_in_agentic_systems_blog.docx', 'paragraph_text': 'Document indexing is like creating a detailed map of a rugged terrain. It transforms information into a structured format, making it easier to retrieve. Semantic search, on the other hand, goes beyond the words to grasp the meaning, making your search more intuitive and accurate.'}
action: append_paragraph_to_word_doc(args={"doc_filename": "understanding_retrieval_in_agentic_systems_blog.docx", "paragraph_text": "Document indexing is like creating a detailed map of a rugged terrain. It transforms information into a structured format, making it easier to retrieve. Semantic search, on the other hand, goes beyond the words to grasp the meaning, making your search more intuitive and accurate."}) -> Paragraph added successfully.
action: append_paragraph_to_word_doc -> {'name': 'append_paragraph_to_word_doc', 'group': 'word_actions', 'pointer': <function append_paragraph_to_word_doc at 0x00000257901B9990>, 'agent_action': {'type': 'function', 'function': {'name': 'append_paragraph_to_word_doc', 'description': '\n    Append a paragraph to a Word document.\n\n    Parameters:\n    doc_filename (str): The path to the Word document.\n    paragraph_text (str): The text to append as a paragraph.\n    ', 'parameters': {'type': 'object', 'properties': {'doc_filename': {'type': 'string', 'description': 'doc_filename'}, 'paragraph_text': {'type': 'string', 'description': 'paragraph_text'}}, 'required': ['doc_filename', 'paragraph_text']}}}, 'prompt_template': None}
action: append_paragraph_to_word_doc -> {'doc_filename': 'understanding_retrieval_in_agentic_systems_blog.docx', 'paragraph_text': 'Semantic search relies on understanding the context and semantics of the words in a document rather than just matching keywords. This makes it extraordinarily potent, especially in complex queries where meaning takes precedence over exact word matches. By using techniques like vector similarity searches, it can compare the semantic content of documents, leading to more accurate and relevant results.'}
action: append_paragraph_to_word_doc(args={"doc_filename": "understanding_retrieval_in_agentic_systems_blog.docx", "paragraph_text": "Semantic search relies on understanding the context and semantics of the words in a document rather than just matching keywords. This makes it extraordinarily potent, especially in complex queries where meaning takes precedence over exact word matches. By using techniques like vector similarity searches, it can compare the semantic content of documents, leading to more accurate and relevant results."}) -> Paragraph added successfully.
action: append_paragraph_to_word_doc -> {'name': 'append_paragraph_to_word_doc', 'group': 'word_actions', 'pointer': <function append_paragraph_to_word_doc at 0x00000257901B9990>, 'agent_action': {'type': 'function', 'function': {'name': 'append_paragraph_to_word_doc', 'description': '\n    Append a paragraph to a Word document.\n\n    Parameters:\n    doc_filename (str): The path to the Word document.\n    paragraph_text (str): The text to append as a paragraph.\n    ', 'parameters': {'type': 'object', 'properties': {'doc_filename': {'type': 'string', 'description': 'doc_filename'}, 'paragraph_text': {'type': 'string', 'description': 'paragraph_text'}}, 'required': ['doc_filename', 'paragraph_text']}}}, 'prompt_template': None}
action: append_paragraph_to_word_doc -> {'doc_filename': 'understanding_retrieval_in_agentic_systems_blog.docx', 'paragraph_text': 'The process begins with transforming a document into a semantic vector, a numerical representation that captures the meaning of the text. Various algorithms, such as TF-IDF, are used to create these vectors. Understanding how these vectors work, and how they can be searched, is essential for building an efficient retrieval system.'}
action: append_paragraph_to_word_doc(args={"doc_filename": "understanding_retrieval_in_agentic_systems_blog.docx", "paragraph_text": "The process begins with transforming a document into a semantic vector, a numerical representation that captures the meaning of the text. Various algorithms, such as TF-IDF, are used to create these vectors. Understanding how these vectors work, and how they can be searched, is essential for building an efficient retrieval system."}) -> Paragraph added successfully.
action: append_image_to_word_doc -> {'name': 'append_image_to_word_doc', 'group': 'word_actions', 'pointer': <function append_image_to_word_doc at 0x00000257901BAD40>, 'agent_action': {'type': 'function', 'function': {'name': 'append_image_to_word_doc', 'description': '\n    Append an image with a caption to a Word document.\n\n    Parameters:\n    doc_filename (str): The path to the Word document.\n    image_filename (str): The path to the image file to append.\n    caption_text (str): The caption text to append below the image.\n    ', 'parameters': {'type': 'object', 'properties': {'doc_filename': {'type': 'string', 'description': 'doc_filename'}, 'image_filename': {'type': 'string', 'description': 'image_filename'}, 'caption_text': {'type': 'string', 'description': 'caption_text'}}, 'required': ['doc_filename', 'image_filename', 'caption_text']}}}, 'prompt_template': None}
action: append_image_to_word_doc -> {'doc_filename': 'understanding_retrieval_in_agentic_systems_blog.docx', 'image_filename': 'images/image4.png', 'caption_text': 'Cosine Similarity'}
action: append_image_to_word_doc(args={"doc_filename": "understanding_retrieval_in_agentic_systems_blog.docx", "image_filename": "images/image4.png", "caption_text": "Cosine Similarity"}) -> Image added successfully.
action: append_code_to_word_doc -> {'name': 'append_code_to_word_doc', 'group': 'word_actions', 'pointer': <function append_code_to_word_doc at 0x00000257901BB6D0>, 'agent_action': {'type': 'function', 'function': {'name': 'append_code_to_word_doc', 'description': '\n    Append a code block to a Word document.\n\n    Parameters:\n    doc_filename (str): The path to the Word document.\n    code_text (str): The code text to append.\n    ', 'parameters': {'type': 'object', 'properties': {'doc_filename': {'type': 'string', 'description': 'doc_filename'}, 'code_text': {'type': 'string', 'description': 'code_text'}}, 'required': ['doc_filename', 'code_text']}}}, 'prompt_template': None}
action: append_code_to_word_doc -> {'doc_filename': 'understanding_retrieval_in_agentic_systems_blog.docx', 'code_text': 'cosine_similarities = cosine_similarity(X)\n\nwhile True:\n    selected_document_index = input(f"Enter a document number (0-{len(documents)-1}) or \'exit\' to quit: ").strip()\n\n    if selected_document_index.lower() == \'exit\':\n        break\n\n    if not selected_document_index.isdigit() or not 0 <= int(selected_document_index) < len(documents):\n        print("Invalid input. Please enter a valid document number.")\n        continue\n\n    selected_document_index = int(selected_document_index)\n    selected_document_similarities = cosine_similarities[selected_document_index]'}
action: append_code_to_word_doc(args={"doc_filename": "understanding_retrieval_in_agentic_systems_blog.docx", "code_text": "cosine_similarities = cosine_similarity(X)\n\nwhile True:\n    selected_document_index = input(f\"Enter a document number (0-{len(documents)-1}) or 'exit' to quit: \").strip()\n\n    if selected_document_index.lower() == 'exit':\n        break\n\n    if not selected_document_index.isdigit() or not 0 <= int(selected_document_index) < len(documents):\n        print(\"Invalid input. Please enter a valid document number.\")\n        continue\n\n    selected_document_index = int(selected_document_index)\n    selected_document_similarities = cosine_similarities[selected_document_index]"}) -> Code block added successfully.
action: append_heading_to_word_doc -> {'name': 'append_heading_to_word_doc', 'group': 'word_actions', 'pointer': <function append_heading_to_word_doc at 0x00000257901BA320>, 'agent_action': {'type': 'function', 'function': {'name': 'append_heading_to_word_doc', 'description': '\n    Append a heading to a Word document.\n\n    Parameters:\n    doc_filename (str): The path to the Word document.\n    heading_text (str): The text to append as a heading.\n    level (int): The heading level (0-9).\n    ', 'parameters': {'type': 'object', 'properties': {'doc_filename': {'type': 'string', 'description': 'doc_filename'}, 'heading_text': {'type': 'string', 'description': 'heading_text'}, 'level': {'type': 'string', 'description': 'level'}}, 'required': ['doc_filename', 'heading_text', 'level']}}}, 'prompt_template': None}
action: append_heading_to_word_doc -> {'doc_filename': 'understanding_retrieval_in_agentic_systems_blog.docx', 'heading_text': 'Vector Databases and Similarity Search', 'level': '1'}
action: append_heading_to_word_doc(args={"doc_filename": "understanding_retrieval_in_agentic_systems_blog.docx", "heading_text": "Vector Databases and Similarity Search", "level": "1"}) -> Heading added successfully.
action: append_paragraph_to_word_doc -> {'name': 'append_paragraph_to_word_doc', 'group': 'word_actions', 'pointer': <function append_paragraph_to_word_doc at 0x00000257901B9990>, 'agent_action': {'type': 'function', 'function': {'name': 'append_paragraph_to_word_doc', 'description': '\n    Append a paragraph to a Word document.\n\n    Parameters:\n    doc_filename (str): The path to the Word document.\n    paragraph_text (str): The text to append as a paragraph.\n    ', 'parameters': {'type': 'object', 'properties': {'doc_filename': {'type': 'string', 'description': 'doc_filename'}, 'paragraph_text': {'type': 'string', 'description': 'paragraph_text'}}, 'required': ['doc_filename', 'paragraph_text']}}}, 'prompt_template': None}
action: append_paragraph_to_word_doc -> {'doc_filename': 'understanding_retrieval_in_agentic_systems_blog.docx', 'paragraph_text': 'Once vectorized, these document vectors are stored in a vector database. This storage allows fast similarity searches, enabling the AI to fetch relevant contexts swiftly. The ability to perform efficient similarity searches ensures the AI remains responsive and relevant.'}
action: append_paragraph_to_word_doc(args={"doc_filename": "understanding_retrieval_in_agentic_systems_blog.docx", "paragraph_text": "Once vectorized, these document vectors are stored in a vector database. This storage allows fast similarity searches, enabling the AI to fetch relevant contexts swiftly. The ability to perform efficient similarity searches ensures the AI remains responsive and relevant."}) -> Paragraph added successfully.
action: append_paragraph_to_word_doc -> {'name': 'append_paragraph_to_word_doc', 'group': 'word_actions', 'pointer': <function append_paragraph_to_word_doc at 0x00000257901B9990>, 'agent_action': {'type': 'function', 'function': {'name': 'append_paragraph_to_word_doc', 'description': '\n    Append a paragraph to a Word document.\n\n    Parameters:\n    doc_filename (str): The path to the Word document.\n    paragraph_text (str): The text to append as a paragraph.\n    ', 'parameters': {'type': 'object', 'properties': {'doc_filename': {'type': 'string', 'description': 'doc_filename'}, 'paragraph_text': {'type': 'string', 'description': 'paragraph_text'}}, 'required': ['doc_filename', 'paragraph_text']}}}, 'prompt_template': None}
action: append_paragraph_to_word_doc -> {'doc_filename': 'understanding_retrieval_in_agentic_systems_blog.docx', 'paragraph_text': 'Vector databases are pivotal in managing and querying large volumes of vectorized data. They enable the efficient retrieval of similar vectors using various similarity measures such as cosine similarity. This efficiency is vital for real-time applications, where prompt and accurate data retrieval is critical.'}
action: append_paragraph_to_word_doc(args={"doc_filename": "understanding_retrieval_in_agentic_systems_blog.docx", "paragraph_text": "Vector databases are pivotal in managing and querying large volumes of vectorized data. They enable the efficient retrieval of similar vectors using various similarity measures such as cosine similarity. This efficiency is vital for real-time applications, where prompt and accurate data retrieval is critical."}) -> Paragraph added successfully.
action: append_paragraph_to_word_doc -> {'name': 'append_paragraph_to_word_doc', 'group': 'word_actions', 'pointer': <function append_paragraph_to_word_doc at 0x00000257901B9990>, 'agent_action': {'type': 'function', 'function': {'name': 'append_paragraph_to_word_doc', 'description': '\n    Append a paragraph to a Word document.\n\n    Parameters:\n    doc_filename (str): The path to the Word document.\n    paragraph_text (str): The text to append as a paragraph.\n    ', 'parameters': {'type': 'object', 'properties': {'doc_filename': {'type': 'string', 'description': 'doc_filename'}, 'paragraph_text': {'type': 'string', 'description': 'paragraph_text'}}, 'required': ['doc_filename', 'paragraph_text']}}}, 'prompt_template': None}
action: append_paragraph_to_word_doc -> {'doc_filename': 'understanding_retrieval_in_agentic_systems_blog.docx', 'paragraph_text': 'This process involves several layers, starting from loading the data, transforming it into vectors, and then storing these vectors in a database optimized for similarity search. Each step in the process is crucial for maintaining the fidelity and speed of the retrieval system.'}
action: append_paragraph_to_word_doc(args={"doc_filename": "understanding_retrieval_in_agentic_systems_blog.docx", "paragraph_text": "This process involves several layers, starting from loading the data, transforming it into vectors, and then storing these vectors in a database optimized for similarity search. Each step in the process is crucial for maintaining the fidelity and speed of the retrieval system."}) -> Paragraph added successfully.
action: append_image_to_word_doc -> {'name': 'append_image_to_word_doc', 'group': 'word_actions', 'pointer': <function append_image_to_word_doc at 0x00000257901BAD40>, 'agent_action': {'type': 'function', 'function': {'name': 'append_image_to_word_doc', 'description': '\n    Append an image with a caption to a Word document.\n\n    Parameters:\n    doc_filename (str): The path to the Word document.\n    image_filename (str): The path to the image file to append.\n    caption_text (str): The caption text to append below the image.\n    ', 'parameters': {'type': 'object', 'properties': {'doc_filename': {'type': 'string', 'description': 'doc_filename'}, 'image_filename': {'type': 'string', 'description': 'image_filename'}, 'caption_text': {'type': 'string', 'description': 'caption_text'}}, 'required': ['doc_filename', 'image_filename', 'caption_text']}}}, 'prompt_template': None}
action: append_image_to_word_doc -> {'doc_filename': 'understanding_retrieval_in_agentic_systems_blog.docx', 'image_filename': 'images/image5.png', 'caption_text': 'Vector Similarity'}
action: append_image_to_word_doc(args={"doc_filename": "understanding_retrieval_in_agentic_systems_blog.docx", "image_filename": "images/image5.png", "caption_text": "Vector Similarity"}) -> Image added successfully.
action: append_heading_to_word_doc -> {'name': 'append_heading_to_word_doc', 'group': 'word_actions', 'pointer': <function append_heading_to_word_doc at 0x00000257901BA320>, 'agent_action': {'type': 'function', 'function': {'name': 'append_heading_to_word_doc', 'description': '\n    Append a heading to a Word document.\n\n    Parameters:\n    doc_filename (str): The path to the Word document.\n    heading_text (str): The text to append as a heading.\n    level (int): The heading level (0-9).\n    ', 'parameters': {'type': 'object', 'properties': {'doc_filename': {'type': 'string', 'description': 'doc_filename'}, 'heading_text': {'type': 'string', 'description': 'heading_text'}, 'level': {'type': 'string', 'description': 'level'}}, 'required': ['doc_filename', 'heading_text', 'level']}}}, 'prompt_template': None}
action: append_heading_to_word_doc -> {'doc_filename': 'understanding_retrieval_in_agentic_systems_blog.docx', 'heading_text': 'Constructing RAG with LangChain', 'level': '1'}
action: append_heading_to_word_doc(args={"doc_filename": "understanding_retrieval_in_agentic_systems_blog.docx", "heading_text": "Constructing RAG with LangChain", "level": "1"}) -> Heading added successfully.
action: append_paragraph_to_word_doc -> {'name': 'append_paragraph_to_word_doc', 'group': 'word_actions', 'pointer': <function append_paragraph_to_word_doc at 0x00000257901B9990>, 'agent_action': {'type': 'function', 'function': {'name': 'append_paragraph_to_word_doc', 'description': '\n    Append a paragraph to a Word document.\n\n    Parameters:\n    doc_filename (str): The path to the Word document.\n    paragraph_text (str): The text to append as a paragraph.\n    ', 'parameters': {'type': 'object', 'properties': {'doc_filename': {'type': 'string', 'description': 'doc_filename'}, 'paragraph_text': {'type': 'string', 'description': 'paragraph_text'}}, 'required': ['doc_filename', 'paragraph_text']}}}, 'prompt_template': None}
action: append_paragraph_to_word_doc -> {'doc_filename': 'understanding_retrieval_in_agentic_systems_blog.docx', 'paragraph_text': "LangChain offers powerful tools to implement RAG workflows. It abstracts retrieval processes, making them accessible and efficient. By using LangChain, we can build robust, scalable retrieval systems that enhance the AI's knowledge and memory capabilities."}
action: append_paragraph_to_word_doc(args={"doc_filename": "understanding_retrieval_in_agentic_systems_blog.docx", "paragraph_text": "LangChain offers powerful tools to implement RAG workflows. It abstracts retrieval processes, making them accessible and efficient. By using LangChain, we can build robust, scalable retrieval systems that enhance the AI's knowledge and memory capabilities."}) -> Paragraph added successfully.
action: append_paragraph_to_word_doc -> {'name': 'append_paragraph_to_word_doc', 'group': 'word_actions', 'pointer': <function append_paragraph_to_word_doc at 0x00000257901B9990>, 'agent_action': {'type': 'function', 'function': {'name': 'append_paragraph_to_word_doc', 'description': '\n    Append a paragraph to a Word document.\n\n    Parameters:\n    doc_filename (str): The path to the Word document.\n    paragraph_text (str): The text to append as a paragraph.\n    ', 'parameters': {'type': 'object', 'properties': {'doc_filename': {'type': 'string', 'description': 'doc_filename'}, 'paragraph_text': {'type': 'string', 'description': 'paragraph_text'}}, 'required': ['doc_filename', 'paragraph_text']}}}, 'prompt_template': None}
action: append_paragraph_to_word_doc -> {'doc_filename': 'understanding_retrieval_in_agentic_systems_blog.docx', 'paragraph_text': 'One of the critical aspects of LangChain is its ability to handle various data sources and vector stores seamlessly. It provides a set of comprehensive tools to perform data loading, vectorization, and querying, making the development process straightforward and efficient. This flexibility is essential for developing scalable and versatile AI systems.'}
action: append_paragraph_to_word_doc(args={"doc_filename": "understanding_retrieval_in_agentic_systems_blog.docx", "paragraph_text": "One of the critical aspects of LangChain is its ability to handle various data sources and vector stores seamlessly. It provides a set of comprehensive tools to perform data loading, vectorization, and querying, making the development process straightforward and efficient. This flexibility is essential for developing scalable and versatile AI systems."}) -> Paragraph added successfully.
action: append_paragraph_to_word_doc -> {'name': 'append_paragraph_to_word_doc', 'group': 'word_actions', 'pointer': <function append_paragraph_to_word_doc at 0x00000257901B9990>, 'agent_action': {'type': 'function', 'function': {'name': 'append_paragraph_to_word_doc', 'description': '\n    Append a paragraph to a Word document.\n\n    Parameters:\n    doc_filename (str): The path to the Word document.\n    paragraph_text (str): The text to append as a paragraph.\n    ', 'parameters': {'type': 'object', 'properties': {'doc_filename': {'type': 'string', 'description': 'doc_filename'}, 'paragraph_text': {'type': 'string', 'description': 'paragraph_text'}}, 'required': ['doc_filename', 'paragraph_text']}}}, 'prompt_template': None}
action: append_paragraph_to_word_doc -> {'doc_filename': 'understanding_retrieval_in_agentic_systems_blog.docx', 'paragraph_text': 'Creating a RAG workflow with LangChain involves several steps. First, documents are loaded and split into manageable chunks. These chunks are then transformed into vectors, typically using models like OpenAI embeddings. Finally, these vectors are stored in a database, ready to be queried for similarity search when needed.'}
action: append_paragraph_to_word_doc(args={"doc_filename": "understanding_retrieval_in_agentic_systems_blog.docx", "paragraph_text": "Creating a RAG workflow with LangChain involves several steps. First, documents are loaded and split into manageable chunks. These chunks are then transformed into vectors, typically using models like OpenAI embeddings. Finally, these vectors are stored in a database, ready to be queried for similarity search when needed."}) -> Paragraph added successfully.
action: append_image_to_word_doc -> {'name': 'append_image_to_word_doc', 'group': 'word_actions', 'pointer': <function append_image_to_word_doc at 0x00000257901BAD40>, 'agent_action': {'type': 'function', 'function': {'name': 'append_image_to_word_doc', 'description': '\n    Append an image with a caption to a Word document.\n\n    Parameters:\n    doc_filename (str): The path to the Word document.\n    image_filename (str): The path to the image file to append.\n    caption_text (str): The caption text to append below the image.\n    ', 'parameters': {'type': 'object', 'properties': {'doc_filename': {'type': 'string', 'description': 'doc_filename'}, 'image_filename': {'type': 'string', 'description': 'image_filename'}, 'caption_text': {'type': 'string', 'description': 'caption_text'}}, 'required': ['doc_filename', 'image_filename', 'caption_text']}}}, 'prompt_template': None}
action: append_image_to_word_doc -> {'doc_filename': 'understanding_retrieval_in_agentic_systems_blog.docx', 'image_filename': 'images/image7.png', 'caption_text': 'LangChain Process'}
action: append_image_to_word_doc(args={"doc_filename": "understanding_retrieval_in_agentic_systems_blog.docx", "image_filename": "images/image7.png", "caption_text": "LangChain Process"}) -> Image added successfully.
action: append_code_to_word_doc -> {'name': 'append_code_to_word_doc', 'group': 'word_actions', 'pointer': <function append_code_to_word_doc at 0x00000257901BB6D0>, 'agent_action': {'type': 'function', 'function': {'name': 'append_code_to_word_doc', 'description': '\n    Append a code block to a Word document.\n\n    Parameters:\n    doc_filename (str): The path to the Word document.\n    code_text (str): The code text to append.\n    ', 'parameters': {'type': 'object', 'properties': {'doc_filename': {'type': 'string', 'description': 'doc_filename'}, 'code_text': {'type': 'string', 'description': 'code_text'}}, 'required': ['doc_filename', 'code_text']}}}, 'prompt_template': None}
action: append_code_to_word_doc -> {'doc_filename': 'understanding_retrieval_in_agentic_systems_blog.docx', 'code_text': 'from langchain.document_loaders import UnstructuredHTMLLoader\nfrom langchain.text_splitter import RecursiveCharacterTextSplitter\n\nloader = UnstructuredHTMLLoader("sample_documents/mother_goose.html")\ndata = loader.load()\n\ntext_splitter = RecursiveCharacterTextSplitter(\n    chunk_size=100,\n    chunk_overlap=25,\n    length_function=len,\n    add_start_index=True,\n)\ndocuments = text_splitter.split_documents(data)'}
action: append_code_to_word_doc(args={"doc_filename": "understanding_retrieval_in_agentic_systems_blog.docx", "code_text": "from langchain.document_loaders import UnstructuredHTMLLoader\nfrom langchain.text_splitter import RecursiveCharacterTextSplitter\n\nloader = UnstructuredHTMLLoader(\"sample_documents/mother_goose.html\")\ndata = loader.load()\n\ntext_splitter = RecursiveCharacterTextSplitter(\n    chunk_size=100,\n    chunk_overlap=25,\n    length_function=len,\n    add_start_index=True,\n)\ndocuments = text_splitter.split_documents(data)"}) -> Code block added successfully.
action: append_heading_to_word_doc -> {'name': 'append_heading_to_word_doc', 'group': 'word_actions', 'pointer': <function append_heading_to_word_doc at 0x00000257901BA320>, 'agent_action': {'type': 'function', 'function': {'name': 'append_heading_to_word_doc', 'description': '\n    Append a heading to a Word document.\n\n    Parameters:\n    doc_filename (str): The path to the Word document.\n    heading_text (str): The text to append as a heading.\n    level (int): The heading level (0-9).\n    ', 'parameters': {'type': 'object', 'properties': {'doc_filename': {'type': 'string', 'description': 'doc_filename'}, 'heading_text': {'type': 'string', 'description': 'heading_text'}, 'level': {'type': 'string', 'description': 'level'}}, 'required': ['doc_filename', 'heading_text', 'level']}}}, 'prompt_template': None}
action: append_heading_to_word_doc -> {'doc_filename': 'understanding_retrieval_in_agentic_systems_blog.docx', 'heading_text': 'Implementing Memory in Agentic Systems', 'level': '1'}
action: append_heading_to_word_doc(args={"doc_filename": "understanding_retrieval_in_agentic_systems_blog.docx", "heading_text": "Implementing Memory in Agentic Systems", "level": "1"}) -> Heading added successfully.
action: append_paragraph_to_word_doc -> {'name': 'append_paragraph_to_word_doc', 'group': 'word_actions', 'pointer': <function append_paragraph_to_word_doc at 0x00000257901B9990>, 'agent_action': {'type': 'function', 'function': {'name': 'append_paragraph_to_word_doc', 'description': '\n    Append a paragraph to a Word document.\n\n    Parameters:\n    doc_filename (str): The path to the Word document.\n    paragraph_text (str): The text to append as a paragraph.\n    ', 'parameters': {'type': 'object', 'properties': {'doc_filename': {'type': 'string', 'description': 'doc_filename'}, 'paragraph_text': {'type': 'string', 'description': 'paragraph_text'}}, 'required': ['doc_filename', 'paragraph_text']}}}, 'prompt_template': None}
action: append_paragraph_to_word_doc -> {'doc_filename': 'understanding_retrieval_in_agentic_systems_blog.docx', 'paragraph_text': 'Agentic memory incorporates various forms—sensory, short-term, and long-term—to enrich interactions. Each type of memory enhances the AI’s capability to contextualize responses based on past interactions, making conversations more natural and meaningful.'}
action: append_paragraph_to_word_doc(args={"doc_filename": "understanding_retrieval_in_agentic_systems_blog.docx", "paragraph_text": "Agentic memory incorporates various forms—sensory, short-term, and long-term—to enrich interactions. Each type of memory enhances the AI’s capability to contextualize responses based on past interactions, making conversations more natural and meaningful."}) -> Paragraph added successfully.
action: append_paragraph_to_word_doc -> {'name': 'append_paragraph_to_word_doc', 'group': 'word_actions', 'pointer': <function append_paragraph_to_word_doc at 0x00000257901B9990>, 'agent_action': {'type': 'function', 'function': {'name': 'append_paragraph_to_word_doc', 'description': '\n    Append a paragraph to a Word document.\n\n    Parameters:\n    doc_filename (str): The path to the Word document.\n    paragraph_text (str): The text to append as a paragraph.\n    ', 'parameters': {'type': 'object', 'properties': {'doc_filename': {'type': 'string', 'description': 'doc_filename'}, 'paragraph_text': {'type': 'string', 'description': 'paragraph_text'}}, 'required': ['doc_filename', 'paragraph_text']}}}, 'prompt_template': None}
action: append_paragraph_to_word_doc -> {'doc_filename': 'understanding_retrieval_in_agentic_systems_blog.docx', 'paragraph_text': 'Sensory memory in AI processes immediate inputs like text, images, and audio, providing rapid but temporary contextual information. Short-term or working memory holds a limited amount of recent input, allowing the system to maintain context over the course of an interaction. Long-term memory stores more durable, relevant semantic and episodic memories which can be recalled over extended periods.'}
action: append_paragraph_to_word_doc(args={"doc_filename": "understanding_retrieval_in_agentic_systems_blog.docx", "paragraph_text": "Sensory memory in AI processes immediate inputs like text, images, and audio, providing rapid but temporary contextual information. Short-term or working memory holds a limited amount of recent input, allowing the system to maintain context over the course of an interaction. Long-term memory stores more durable, relevant semantic and episodic memories which can be recalled over extended periods."}) -> Paragraph added successfully.
action: append_paragraph_to_word_doc -> {'name': 'append_paragraph_to_word_doc', 'group': 'word_actions', 'pointer': <function append_paragraph_to_word_doc at 0x00000257901B9990>, 'agent_action': {'type': 'function', 'function': {'name': 'append_paragraph_to_word_doc', 'description': '\n    Append a paragraph to a Word document.\n\n    Parameters:\n    doc_filename (str): The path to the Word document.\n    paragraph_text (str): The text to append as a paragraph.\n    ', 'parameters': {'type': 'object', 'properties': {'doc_filename': {'type': 'string', 'description': 'doc_filename'}, 'paragraph_text': {'type': 'string', 'description': 'paragraph_text'}}, 'required': ['doc_filename', 'paragraph_text']}}}, 'prompt_template': None}
action: append_paragraph_to_word_doc -> {'doc_filename': 'understanding_retrieval_in_agentic_systems_blog.docx', 'paragraph_text': 'Memory retrieval in AI systems follows a similar pattern to RAG but focuses more on the dynamic and evolving nature of accumulated information. By effectively categorizing and managing these different forms of memory, AI systems can simulate a more nuanced understanding, similar to human cognitive processes.'}
action: append_paragraph_to_word_doc(args={"doc_filename": "understanding_retrieval_in_agentic_systems_blog.docx", "paragraph_text": "Memory retrieval in AI systems follows a similar pattern to RAG but focuses more on the dynamic and evolving nature of accumulated information. By effectively categorizing and managing these different forms of memory, AI systems can simulate a more nuanced understanding, similar to human cognitive processes."}) -> Paragraph added successfully.
action: append_image_to_word_doc -> {'name': 'append_image_to_word_doc', 'group': 'word_actions', 'pointer': <function append_image_to_word_doc at 0x00000257901BAD40>, 'agent_action': {'type': 'function', 'function': {'name': 'append_image_to_word_doc', 'description': '\n    Append an image with a caption to a Word document.\n\n    Parameters:\n    doc_filename (str): The path to the Word document.\n    image_filename (str): The path to the image file to append.\n    caption_text (str): The caption text to append below the image.\n    ', 'parameters': {'type': 'object', 'properties': {'doc_filename': {'type': 'string', 'description': 'doc_filename'}, 'image_filename': {'type': 'string', 'description': 'image_filename'}, 'caption_text': {'type': 'string', 'description': 'caption_text'}}, 'required': ['doc_filename', 'image_filename', 'caption_text']}}}, 'prompt_template': None}
action: append_image_to_word_doc -> {'doc_filename': 'understanding_retrieval_in_agentic_systems_blog.docx', 'image_filename': 'images/image21.png', 'caption_text': 'Memory Workflow'}
action: append_image_to_word_doc(args={"doc_filename": "understanding_retrieval_in_agentic_systems_blog.docx", "image_filename": "images/image21.png", "caption_text": "Memory Workflow"}) -> Image added successfully.
action: append_heading_to_word_doc -> {'name': 'append_heading_to_word_doc', 'group': 'word_actions', 'pointer': <function append_heading_to_word_doc at 0x00000257901BA320>, 'agent_action': {'type': 'function', 'function': {'name': 'append_heading_to_word_doc', 'description': '\n    Append a heading to a Word document.\n\n    Parameters:\n    doc_filename (str): The path to the Word document.\n    heading_text (str): The text to append as a heading.\n    level (int): The heading level (0-9).\n    ', 'parameters': {'type': 'object', 'properties': {'doc_filename': {'type': 'string', 'description': 'doc_filename'}, 'heading_text': {'type': 'string', 'description': 'heading_text'}, 'level': {'type': 'string', 'description': 'level'}}, 'required': ['doc_filename', 'heading_text', 'level']}}}, 'prompt_template': None}
action: append_heading_to_word_doc -> {'doc_filename': 'understanding_retrieval_in_agentic_systems_blog.docx', 'heading_text': 'Conclusion', 'level': '1'}
action: append_heading_to_word_doc(args={"doc_filename":"understanding_retrieval_in_agentic_systems_blog.docx","heading_text":"Conclusion","level":"1"}) -> Heading added successfully.
action: append_paragraph_to_word_doc -> {'name': 'append_paragraph_to_word_doc', 'group': 'word_actions', 'pointer': <function append_paragraph_to_word_doc at 0x00000257901B9990>, 'agent_action': {'type': 'function', 'function': {'name': 'append_paragraph_to_word_doc', 'description': '\n    Append a paragraph to a Word document.\n\n    Parameters:\n    doc_filename (str): The path to the Word document.\n    paragraph_text (str): The text to append as a paragraph.\n    ', 'parameters': {'type': 'object', 'properties': {'doc_filename': {'type': 'string', 'description': 'doc_filename'}, 'paragraph_text': {'type': 'string', 'description': 'paragraph_text'}}, 'required': ['doc_filename', 'paragraph_text']}}}, 'prompt_template': None}
action: append_paragraph_to_word_doc -> {'doc_filename': 'understanding_retrieval_in_agentic_systems_blog.docx', 'paragraph_text': "The journey through retrieval in agentic systems reveals a rich landscape where memory and knowledge intertwine. From semantic search to advanced memory implementations, each step enhances the capability and depth of AI interactions. As we continue to explore these terrains, the potential for more intelligent and intuitive systems burgeons, promising a future where AI doesn't just respond but understands."}
action: append_paragraph_to_word_doc(args={"doc_filename":"understanding_retrieval_in_agentic_systems_blog.docx","paragraph_text":"The journey through retrieval in agentic systems reveals a rich landscape where memory and knowledge intertwine. From semantic search to advanced memory implementations, each step enhances the capability and depth of AI interactions. As we continue to explore these terrains, the potential for more intelligent and intuitive systems burgeons, promising a future where AI doesn't just respond but understands."}) -> Paragraph added successfully.
assistant > action: create_image -> {'name': 'create_image', 'group': 'image_actions', 'pointer': <function create_image at 0x00000257EEE75E10>, 'agent_action': {'type': 'function', 'function': {'name': 'create_image', 'description': '\n    Generate an image based on the provided prompt using the DALL-E model.\n    Args:\n        prompt (str): The prompt used to generate the image.\n        model (str, optional): The model used to generate the image. Defaults to "dall-e-3".\n        size (str, optional): The size of the image in pixels. Defaults to "1024x1024". Options are 1024x1024, 1024x1792 or 1792x1024.\n        quality (str, optional): The quality of the generation. Defaults to "standard". Options are "standard" or "hd" for high definition.\n        n (int, optional): The number of generations. Defaults to 1. Always 1 for now.\n    Returns:\n        str: The path to the generated image file.\n    ', 'parameters': {'type': 'object', 'properties': {'prompt': {'type': 'string', 'description': 'prompt'}, 'model': {'type': 'string', 'description': 'model'}, 'size': {'type': 'string', 'description': 'size'}, 'quality': {'type': 'string', 'description': 'quality'}, 'n': {'type': 'string', 'description': 'n'}}, 'required': ['prompt']}}}, 'prompt_template': None}
action: create_image -> {'prompt': 'A detailed visual representation of AI systems showing document retrieval, memory, semantic search, vector databases, and interactions within agentic systems. Include elements like vector embeddings, document splitting, and agents interacting with a database.', 'model': 'dall-e-3', 'size': '1024x1024'}
action: create_image(args={"prompt":"A detailed visual representation of AI systems showing document retrieval, memory, semantic search, vector databases, and interactions within agentic systems. Include elements like vector embeddings, document splitting, and agents interacting with a database.","model":"dall-e-3","size":"1024x1024"}) -> A_detailed_visual_representation_of_AI_systems_sho.png
assistant > 